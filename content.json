{"meta":{"title":"书生","subtitle":"书生の博客","description":"IT | 计算机应用","author":"书生","url":"https://yanjiuzhe.github.io","root":"/"},"pages":[{"title":"404","date":"2021-08-15T16:00:00.000Z","updated":"2021-08-19T03:20:28.764Z","comments":true,"path":"404.html","permalink":"https://yanjiuzhe.github.io/404.html","excerpt":"","text":""},{"title":"","date":"2021-08-16T01:45:37.227Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"google1xxxxxxx0.html","permalink":"https://yanjiuzhe.github.io/google1xxxxxxx0.html","excerpt":"","text":"google-site-verification: google110e5e5e14c8dcf0.html"},{"title":"","date":"2021-08-16T01:45:37.223Z","updated":"2021-06-13T05:55:39.000Z","comments":true,"path":"baidu_verify_xxxxxxx.html","permalink":"https://yanjiuzhe.github.io/baidu_verify_xxxxxxx.html","excerpt":"","text":"wvlc3L96QK"},{"title":"放松一下","date":"2021-08-15T16:00:00.000Z","updated":"2021-08-18T03:23:38.486Z","comments":true,"path":"List/index.html","permalink":"https://yanjiuzhe.github.io/List/index.html","excerpt":"","text":"影音资源共享"},{"title":"archives","date":"2021-08-15T16:00:00.000Z","updated":"2021-08-18T03:21:14.104Z","comments":true,"path":"archives/index.html","permalink":"https://yanjiuzhe.github.io/archives/index.html","excerpt":"","text":""},{"title":"about","date":"2021-08-15T16:00:00.000Z","updated":"2021-08-18T03:20:54.401Z","comments":true,"path":"about/index.html","permalink":"https://yanjiuzhe.github.io/about/index.html","excerpt":"","text":""},{"title":"留言板","date":"2021-08-15T16:00:00.000Z","updated":"2021-08-18T03:22:17.720Z","comments":true,"path":"contact/index.html","permalink":"https://yanjiuzhe.github.io/contact/index.html","excerpt":"","text":"畅所欲言 在这里可以留下你的足迹，欢迎在下方留言，欢迎交换友链，一起交流学习！ 友链 书生の友链信息 博客名称: 书生の博客 博客网址: https://yanjiuzhe.github.io/ 博客头像: https://z3.ax1x.com/2021/08/16/fWplYd.jpg 博客介绍: Try to make yourself shine first, and the person you love can come to meet the light."},{"title":"categories","date":"2021-08-15T16:00:00.000Z","updated":"2021-08-18T03:20:35.883Z","comments":true,"path":"categories/index.html","permalink":"https://yanjiuzhe.github.io/categories/index.html","excerpt":"","text":""},{"title":"友人帐","date":"2021-08-15T16:00:00.000Z","updated":"2021-08-19T03:18:42.811Z","comments":true,"path":"friends/index.html","permalink":"https://yanjiuzhe.github.io/friends/index.html","excerpt":"","text":""},{"title":"资源分享","date":"2021-08-15T16:00:00.000Z","updated":"2021-08-18T03:25:49.215Z","comments":true,"path":"resource/index.html","permalink":"https://yanjiuzhe.github.io/resource/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-08-16T08:40:27.000Z","updated":"2021-08-18T03:20:03.613Z","comments":true,"path":"tags/index.html","permalink":"https://yanjiuzhe.github.io/tags/index.html","excerpt":"","text":""},{"title":"galleries","date":"2021-08-18T03:33:08.000Z","updated":"2021-08-18T04:41:48.355Z","comments":true,"path":"List/galleries/index.html","permalink":"https://yanjiuzhe.github.io/List/galleries/index.html","excerpt":"","text":""},{"title":"视频","date":"2021-08-15T16:00:00.000Z","updated":"2021-08-18T03:26:41.281Z","comments":true,"path":"List/movies/index.html","permalink":"https://yanjiuzhe.github.io/List/movies/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2021-08-15T16:00:00.000Z","updated":"2021-08-18T03:24:40.930Z","comments":true,"path":"List/music/index.html","permalink":"https://yanjiuzhe.github.io/List/music/index.html","excerpt":"","text":""},{"title":"听听音乐","date":"2021-08-15T16:00:00.000Z","updated":"2021-08-18T03:24:10.968Z","comments":true,"path":"List/tools/index.html","permalink":"https://yanjiuzhe.github.io/List/tools/index.html","excerpt":"","text":""},{"title":"动漫","date":"2021-08-15T16:00:00.000Z","updated":"2021-08-18T04:43:36.816Z","comments":true,"path":"List/galleries/动漫/index.html","permalink":"https://yanjiuzhe.github.io/List/galleries/%E5%8A%A8%E6%BC%AB/index.html","excerpt":"","text":""},{"title":"二次元风","date":"2021-08-15T16:00:00.000Z","updated":"2021-08-18T04:45:27.243Z","comments":true,"path":"List/galleries/二次元风/index.html","permalink":"https://yanjiuzhe.github.io/List/galleries/%E4%BA%8C%E6%AC%A1%E5%85%83%E9%A3%8E/index.html","excerpt":"","text":""}],"posts":[{"title":"计算机基础知识","slug":"计算机基础知识","date":"2021-08-19T07:57:51.000Z","updated":"2021-08-19T08:37:11.681Z","comments":true,"path":"posts/6bcf31ad.html","link":"","permalink":"https://yanjiuzhe.github.io/posts/6bcf31ad.html","excerpt":"","text":"第一章、计算机硬件设备一、计算机发展史1、计算机发展历程 2、计算机的分类 超算、巨型计算机、台式机、笔记本、平板、手机 二、计算机硬件组成1、计算机的基本组成: 运算器，控制器，存储器（内存：RAM,ROM；外存：硬盘），输入设备（鼠标，键盘），输出设备（显示器，音箱） 2、计算机系统：硬件系统： ​ 主机： CPU(运算器，控制器)，内存条：(RAM可读写存储器，ROM只读存储器，Cache高速缓存)；主板，硬盘，光驱，软驱，显卡，声卡，网卡，电源，数据线，总线(UBS) ​ 外设： 存储器（外存：硬盘，U盘，软盘，光盘，磁带），输入设备（鼠标，键盘，扫描仪），输出设备（显示器，音箱，打印机）。 RAM与硬盘的区别：RAM容量小，存储速度快，RAM是暂时性存储器，数据保存在电路上，断电丢失。硬盘容量大，数据保存在磁性介质上，会存储长久。 ​ 软件系统： 系统软件（操作系统，语言处理程序，系统管理于服务软件），应用软件（办公软件，娱乐软件） 3、计算机硬件系统： CPU 核心和线程数量： 主频： 外频： 缓存：是继承在CPU中的高速缓存器，用于临时存储数据（L1、L2、L3）。 前端总线频率 主板： 各个部件的物理通道，也是各个部件数据传输的逻辑通道 1）主要参数 南北桥芯片 CPU接口 内存条槽 主板架构：ATX、MicroATX 2）设备接口 硬盘接口 显卡插槽 扩展插槽 扩展接口：USB接口、音频接口、网线接口、VGA接口(接显示器的) 3）集成功能 声卡、网卡、显卡 内存： DDR、DDR2、DDR3、DDR4 容量：4G、8G、16G 工作频率： 硬盘 硬盘与主板的接口：数据接口、电源接口 参数： 类型：机械硬盘，固态硬盘 容量： 转速：10000rpm、7200rpm、5900rpm 盘体尺寸：2.5寸、3.5寸 接口标准：SATA3.0、SATA2.5 缓存容量：64M、32M、16M、8M 显卡 为显示器显示信号 类型：集成显卡、独立显卡 参数： 显示器接口：VGA接口、DVI接口、HDMI接口 显示器 类型：CRT显像管显示器、LCD液晶显示器 参数： 尺寸：14寸、15寸、16寸 接口类型：VGA DVI HDMI USB 亮度 对比度 分辨率：是能标识显示器所能显示的像素 色域 声卡、网卡 声卡：实现声波和数字信号转换的 网卡：实现计算机与外界局域网的连接，并实现数据传输 光驱 电脑读写光盘内容的设备 光盘类型：CD、DVD、BD 光驱读取数据：光驱通过激光头发射光束照射盘片，盘片反射回激光，光头在根据激光的强弱判断获取数据 光驱接口：SATA接口、USB接口（外置光驱） 机箱电源 电源、电源线 4、台式机的的装机步骤 将CPU和散热器安装到主板上 将内存条安装到主板上 将主板固定在机箱上 将显卡、声卡、网卡安装到主机上 将硬盘和光驱连接到主板上 安装电源和连接各个电源线 连接机箱线 盖上机箱，插上鼠标、键盘和音箱 5、计算机硬件故障检测与维护 6、BIOS设置（cmos设置） BIOS是“基本输入输出系统”，它保存着计算机的基本输入输出设备，系统设置信息，开机后自检程序和系统自启程序，为计算机提供最底层的、最直接的硬件设置和控制。 1）Standard CMOS Setup 设置系统日期、时间、IDE设备、显示系统的类型、错误处理方法 2）Boot Sequence：选择机器启动引导系统时的启动顺序 3）Onboard 控制打开关闭主板内置声卡、网卡，选择Auto打开，选择Disable关闭 4）Supervisor Password And User Password Setup：管理员和普通用户密码设置 UserPassword功能设定开机密码 Supervisor Password是为了他人擅自修改CMOS的内容而设置 5）强制恢复BIOS程序的默认设置 BIOS程序：存储计算机最基本的程序（启动、检测、控制设备） CMOS芯片：存储BOIS程序的参数（系统时间、开机密码） 电池：给COMS芯片供电，以保存COMS中的参数（一旦电池没电参数会丢失） 根据该原理将电池取出在放回去，就会丢失用户自己的设置，恢复默认设置 三、计算机的工作原理1、计算机内部应采用二进制表示指令和数据。每条指令一般具有一个操作码和一个地址码，操作码表示运算性质，地址码定义操作数在存储器中的地址。 将编写好的程序和原始数据存入内存器中，然后启动计算机工作，计算机在不需操作人员干预的情况下，自动逐条取出指令和执行任务。 2、工作原理： 用户运行程序的指令 &gt; 计算机将程序和数据输入内存 &gt; CPU根据程序指令运算 &gt; 计算机将结果输出 &gt; 计算机取出下一条指令的地址，并待命。 第二章、计算机软件应用一、计算机操作系统1、操作系统的作用 操作系统介于硬件和软件之间，协调计算机硬件的运作，用户通过操作系统控制硬件和软件 2、操作系统的功能 1）对CPU和进程管理 对CPU管理 处理器管理负责管理，调度和分派计算机资源，并控制程序的执行。就是对进程的管理。4核6线程，对进程之间互相干扰的管理 对进程的管理 进程的组成：程序块，进程控制块，数据块 进程的状态：执行，就绪，等待 2）存储器管理 1） 管理的对象是内存，存储器管理的主要功能是：分配和回收内存空间，提高内存利用率，扩充内存，对内存信息实现有效的保护。 2）虚拟内存：欺骗程序，让它以为现在使用的内存是连续的。当内存(RAM)不够时候，把外存(硬盘)的空间虚拟成内存。 3）设备管理 设备管理是指计算机系统中除了CPU和内存以外的所有输入，输出设备的管理。 按资源分配分类：独占设备(打印机)，共享设备()，虚拟设备() 主要技术：中断技术，通道技术，缓冲技术， 4）文件管理 就是对文件的一个统一组织管理。实质是“按名存取”。 5）作业管理 作业：就是计算机完成一个独立任务的程序以及所需的数据，就是一次作业。 作业管理就是对用户提交的诸多作业进行管理，包括作业的组织，控制和调度等，尽可能的高效的利用整个系统资源。 3、常见的操作系统 Dos系统 Uinux Linux Windows Mac os系统 二、计算机中的信息表示信息的数字化：信息在计算机内部的表现形式是数据，数据在计算机内部的表现形式是二进制，用二进制0和1来表示的信息被称为信息的数字化。 1、进位计数制 二进制，八进制，十进制，十六进制 1TB=1024GB、1GB=1024MB、1MB=1024KB、1KB=1024B、1B=8b,1=0或1 进制数之间的转化 2、数值数据的编码表示 原码，反码，补码 3、非数值数据的表示 ASCII码，国标码，区位码，GBK，UTF-8 三、安装操作系统1、光盘安装操作系统 1）准备一张Windows操作系统的安装光盘 2）将光驱设置为计算机的第一启动设备 在开机的时候按del键或F2键，进入BOIS程序，选择Boot，选择CD-ROM，在按F10确定选择。 3）进入安装程序，选择现在安装Windows 同意安装 4）进行磁盘分区（可选） 对分区进行格式化 选择文件系统：FAT32文件系统、NTFS文件系统 5）输入Windows的密钥 输入用户名和计算机名，一直下一步。 2、U盘安装操作系统 1）制作启动盘 下载装机软件，将U盘插入，制作启动盘。 2）下载Windows10的镜像文件到U盘 Windows-x86-64.ios 3）设置计算机从U盘启动 开机按del键，进入BOIS程序，选择Boot，选择Boot Device Priority，将第一启动设备设置成U盘，按F10保存退出 4）选择启动Windows PE维护系统 Windows PE预安装环境，是一个为Windows安装准备的最小容量操作系统 5）进行磁盘分区（可选） 创建分区，选择文件系统，划分容量，并进行格式化 对已用的磁盘进行分区，先删除逻辑分区，在删除扩展分区，最后删除主分区，在进行重新划分。 6）重启计算机，在使用虚拟光驱加载Windows镜像文件 7）使用桌面的Windows装机工具，进行装机 8）拔出U盘，重启计算机，在开机时按del键，进入BOIS程序，选择Boot，选择Boot Device Priority，将第一启动设备设置成硬盘，按F10保存退出 9）输入Windows的密钥 输入用户名和计算机名，一直下一步。 四、驱动程序驱动程序是直接工作在各种硬件上的软件，能使各个硬件稳定的发挥性能、配和工作。 1、手动安装驱动程序 在Windows系统附带了大量的通用驱动程序，但有时候通用驱动程序和硬件不匹配，就需要要手动安装了。 查看电脑版本号，在网上搜索版本对应的驱动程序，下载、解压、安装。 五、系统管理1、磁盘管理 1）查看磁盘分区 右键Windows属性，选择磁盘管理 2）更改盘符 选择盘符，右键选择驱动器号和路径 3）磁盘清理、碎片整理 选择盘符，右键属性，点击工具 2、账号管理 创建管理员用户，创建本地标准用户 删除用户账号 切换用户账号（注销在登录）","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://yanjiuzhe.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"https://yanjiuzhe.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"}],"author":"书生"},{"title":"python爬虫","slug":"python爬虫","date":"2021-08-19T07:57:38.000Z","updated":"2021-08-19T08:50:04.588Z","comments":true,"path":"posts/dbb714e3.html","link":"","permalink":"https://yanjiuzhe.github.io/posts/dbb714e3.html","excerpt":"","text":"第一章、爬虫简介1、网络爬虫（web crawler：也叫网页蜘蛛，网络机器人，是一种用来自动浏览万维网的程序或者脚本。爬虫可以验证超链接和HTML代码，用于网络抓取（Web scraping）。网络搜索引擎等站点通过爬虫软件更新自身的网站内容（Web content）或其对其他网站的索引。 2、爬虫分类：通用网络爬虫（General Purpose Web Crawler）、聚焦网络爬虫（Focused Web Crawler）、增量式网络爬虫（Incremental Web Crawler）、深层网络爬虫（Deep Web Crawler）。 3、url(统一资源定位符)：http://host[:post][path]http: 超文本传输协议host: IP地址/域名post: 端口号，默认为80path: 请求资源的路径 4、Robots协议 (1)、爬虫的限制： 来源的审查：判断User Agent等进行限制 发布公告：Robots协议 (2)、Robots协议：网络爬虫排除标准形式：网站下的robots.txt文件基本语法：* 代表所有，/代表根目录user-agent: *pisallow: / 第二章、网络请求 requests环境安装：pip install requests 一、requests库的方法1、requests库的七个方法 requests.request(): 构造一个请求 requests.get(): 发起get请求，返回response对象 requests.post(): 向网页发起post请求，并向服务器传递参数 requests.head(): 获取html网页头部信息 requests.put(): 发起put请求 requests.pach(): 向网页发起局部修改请求 requests.delete(): 向网页发起删除请求 二、requests库的get()方法3、 requests库的两个重要参数 request对象：向服务器请求资源 response对象：爬虫返回的内容（响应数据） 1、requests库的get()方法 格式：对URL发起网络请求，并返回response对象(响应数据)。 response = request.get(url) 参数：request.get(url, params, kwargs) --url: 网页地址 --params: url额外参数，字典或字节流格式 --kwargs: 12个控制访问的参数 三、requests库的post()方法格式：对URL发起网络请求，并返回response对象(响应数据)。 response = request.post(url) 参数：request.get(url, data, kwargs) --url: 网页地址 --data: url额外参数，字典或字节流格式 --kwargs: 12个控制访问的参数 四、response对象的属性：response.text: http响应数据的字符串形式，即url页面的内容 response.content: http响应数据的二进制形式 response.status_code：http请求返回的状态，200表示成功。 response.encoding：从http的头部猜测响应数据的编码形式 response.apparent_encoding: 从内容中分析响应数据的编码形式 response.cookies：获取RequestsCookieJar对象 &lt;RequestsCookieJar[&lt;Cookie bid=uk68MyRriZ8 for .douban.com/&gt;]&gt; response.headers：获取头部数据 response.reason：返回状态信息 response.url：返回请求的URL response.raw：获取原始数据 &lt;urllib3.response.HTTPResponse object at 0x00000234271FC820&gt; response.json：序列化为JSON格式数据 &lt;bound method Response.json of &lt;Response [200]&gt;&gt; 六、处理Requests重定向在网络请求时添加：禁止重定向 allow_redirects=False 七、Requests SSL证书验证1、忽视证书 import requests from requests.packages import urllib3 urllib3.disable_warnings() resp = requests.get(\"https://12306.cn\", verify=False) print(resp.status_code) 2、设置本地证书 import requests from requests.packages import urllib3 urllib3.disable_warnings() resp = requests.get(\"https://12306.cn\", cert=(\"**.crt\", \"**key\")) print(resp.status_code) 八、网络请求的编码流程：1. 指定url(网址) url = \"http://baidu.com\" 2. UA伪装，将爬虫的身份标识，伪装成浏览器的请求头(headers)的请求载体的身份标识，可以躲过UA检测。 headers = { \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64)\"; } 3. 处理get/post请求的参数(params/data) params = { \"bs\": \"爬虫\"; } 4. 发起get/post请求，并返回一response对象 response = request.get(url) 5. 获取响应数据，会返回text(字符串)/json(对象)/content(二进制)格式的数据 data = response.text 6. 存储数据 第三章、数据解析一、数据解析简介一）解析模块 1、BeautifulSoup 2、re 3、Xpath 二）数据解析原理： 1、解析的局部的文本内容都会在标签之间或标签属性之中 2、进行指定标签的定位 3、对标签或标签属性之间的数据进行提取(解析) 三）数据解析的编码流程： 1. 指定url(网址) 2. UA伪装，将爬虫的身份标识，伪装成浏览器的请求头(headers)的请求载体的身份标识，可以躲过UA检测。 3. 处理get/post请求的参数(params/data) 4. 发起get/post请求，并返回一response对象 5. 获取响应数据，会返回text/json格式的数据 6. 数据解析(BeautifulSoup/re/xpath),提取局部所需数据 7. 存储数据(txt/csv/jpg/json) 二、re(正则表达式)import re (.*?) 三、BeautifulSoup1、BeautifulSoup进行数据解析原理： 1）实例化一个BeautifulSoup对象，并将网页源码数据加载到该对象中 soup = BeautifulSoup(html, 'lxml') 2）通过调用BeautifulSoup对象中的方法(属性)，进行标签定位和数据提取 title = soup.find_all('span', class_='title') 2、BeautifulSoup对象的实例化： 1). 将本地的html文档中数据加载到该对象中 with open('./哔哩哔哩.html','r',encoding='utf-8') as fp: soup = BeautifulSoup(fp,'lxml') 2). 将互联网上的网页源码加载到该对象中 response_text = response.text soup = BeautifulSoup(response,'lxml') 3、提供的用于数据解析的方法和属性： (1)标签定位： soup.标签名 # 返回soup对象中第一次出现的标签名对应的标签 soup.find: # 返回soup对象中第一次出现的标签名对应的标签 soup.find('标签名') (2)属性定位： # 返回soup对象中第一次出现的标签名和属性名所对应的标签 soup.find('标签'，'属性名') # 返回soup对象中所有出现过的标签名和属性名所对应的标签，是列表类型 soup.findall('标签名'，'属性名') (3)select(选择器)： soup.select(''标签名(div，)' / '.类名(class，)' / '#id名(#id)'，....选择器)') # select()返回的是一个列表,(.表示的类选择器) 组合查找：soup.select('div .类名') # 通过标签和class组合查找，使用空格连接不同方式 soup.select('div #id名') # 通过标签和id组合查找，使用空格连接不同方式 soup.select('a[属性=\"属性名\"]') # 通过标签的属性查找，标签和属性必须在同一个节点内。 层级选择器： soup.select('. &gt; ul &gt; li &gt; a') # .可以是标签/类/id，&gt;表示的是一个层级 soup.selsct('. &gt; ul a') # ul标签和a标签之间有空格，空格表示的是多个层级 (4)获取标签之间的文本数据： soup.标签名.text/.string/.get_text() 区别： text和.get_text()，可以获取一个标签中所有的文本内容 .string，只可以获取该标签下面直系的文本内容 (5)获取标签中的属性值： soup.标签名['属性名'] 四、xpath1、xpath解析原理; （1）.实例化一个etree的对象，且将需要解析的网页源码加载到该对象中 （2）.调用etree对象中的xpath方法，并结合xpath表达式，实现标签的定位和内容的提取 2、etree对象的实例化：from lxml import etree (1). 将本地的html文档中的源码加载到etree对象中 etree.parse(file_path) (2). 将互联网上的网页源码加载到etree对象中 etr = etree.HTML('response_text') data = etr.xpath('xpsth表达式') 3、xpath表达式：(可以直接copy xpath) 1）/表示一个层级，最左边的/表示的是从根节点开始定位 ./表示当前标签 2）//表示多个层级，最左边的//表示的是从任意位置开始定位 3）属性定位：//标签名[@属性名='属性值'] 例如：，返回的是一个列表 //div[@class='class_value'] 4）索引定位： //标签名[@属性名='属性值']/标签名[1] 例如：索引从1开始， //div[@class='class_value']/p[1] 5）提取文本： 提取直系的文本内容：/text() 例如： //div[@class='class_value']/p[1]/text() 提取非直系的文本内容(所有的文本内容)：//text() 例如： //div[@class='class_value']/p[1]//text() 6）提取属性：/@属性名 例如：提取a标签的href属性 //div[@class='class_value']/a/@href 第四章、模拟登录一、模拟登录简介1、验证码识别：识别验证码图片中的数据，用于模拟登录操作 （1）识别验证码的操作：人工识别/第三方自动识别 （2）验证码：每次请求都会发生变化2、模拟登录： 爬取基于某些用户的用户信息 登录流程：获取验证码 &gt; 点击登录后，会发起post请求 &gt; post请求中会携带登录信息 (1). 编码流程：获取验证码 &gt; 发起post请求(处理相关参数) &gt; 数据存储 二、模拟登录的编码流程：1、 需求：对人人网进行模拟登录 1.获取验证码 (1). 指定url(网址) (2). UA伪装，将爬虫的身份标识，伪装成浏览器的请求头(headers)的请求载体的身份标识，可以躲过UA检测。 (4). 发起get请求，并返回response对象 (5). 获取响应数据，会返回text格式的数据 (6). 数据解析(BeautifulSoup/re/xpath),提取验证码图片 (7). 使用打码平台，识别验证码图片，并返回验证码 2、模拟登录的编码流程：需求：爬取登录后的个人主页中显示的用户信息 1.获取验证码 指定url(网址) UA伪装，将爬虫的身份标识，伪装成浏览器的请求头(headers)的请求载体的身份标识，可以躲过UA检测。 发起get请求，并返回一response对象 获取响应数据，会返回text格式的数据 数据解析(BeautifulSoup/re/xpath),提取验证码图片 使用打码平台，识别验证码图片，并返回验证码 2.模拟登录 创建session对象 使用session携带cookie进行发送post请求 三、cookie和session1、http/https协议的特性：无状态没有请求到对应页面的原因：发起的第二次基于个人主页页面请求的时候，服务器不知道该请求是登录状态下的请求。 2、cookie： 用来让服务器端记录客户端的相关状态 cookie操作： 1）手动处理：通过抓包工具获取cookie值，并将该值封装进headers中。 2）自动处理：session 3）cookie值的来源：模拟登录post请求后，由服务器端创建。 session会话对象： 1）session对象的作用： --可以进行请求的发送。 --如果请求过程中产生了cookie，则该cookie值会被自动储存在session对象中。 2）创建一个session对象：session = requests.Session( ) 3）使用session对象进行模拟登录post请求的发送（cookie值就会被存储在session中） 4）session对象对个人主页对应的get请求进行发送（携带了cookie） 第五章、代理IP一、代理IP简介1、代理服务器: 网络信息中的一个中转站。 2、代理服务器的作用： –突破自身IP的访问限制 –隐藏自身的IP，免受攻击 3、代理IP的类型: –http: 只能应用到http协议对应的url中 –https: 只能应用到https协议对应的url中 4、代理IP的匿名度： –透明：服务器知道该次请求使用了代理，也知道请求对应的真实的IP –匿名：服务器知道使用了代理，不知道真实的IP –高匿：服务器不知道使用了代理，更不知到真实的IP 5、IP代理的相关网站 –快代理 –西祠代理 –www.goubanjia.com 二、反爬机制：IP封禁proxies = { 'https': '49.70.32.63:9999' } 第六章、协程&amp;ayncio(异步非阻塞)一、协程简介1、协程: 微线程，通过一个线程让代码之间相互切换的执行。2、实现协程的方式： greenlet (早期模块) yield关键字 asyncio装饰器 async -await关键字（主流） 3、协程的意义：如果一个线程中遇到IO阻塞，线程会利用等待时间，去执行其他任务。类似于时间统筹规划。 二、基于协程的异步编程1、 事件循环(死循环) 例: 任务列表 = [任务1，任务2.......] while True: 可执行的任务列表，已完成的任务列表 = 去任务列表中检查所有任务，将'可执行'和'已完成'的任务返回 for 就绪任务 in 已准备就绪的任务列表： 执行已就绪的任务 for 已完成的任务 in 已完成的任务列表： 在任务列表中移除已完成的任务 如果任务列表中的任务全部完成，则终止循环 2、 协程函数，定义函数时&gt;&gt;&gt; async def 函数名 async def fun(): pass 3、awaitawait + 可等待对象(协程对象，Task对象，Future &gt;&gt;&gt; IO等待)await就是等待对象的值，得到值以后才会往下走。 4、协程对象，执行协程函数()，得到的协程对象,但函数内部的代码不会执行 result = fun() 5、运行协程函数: 需要将协程对象交给事件循环处理 asyncio.run(result) 6、task对象task用于并发的调度协程，帮助我们将多个任务添加到事件循环中。 tasks对象的创建： asyncio.create_task(协程对象) 7、Future对象task继承Future，task对象内部await结果的处理基于Future对象来的。是基于协程实现异步操作时用到的对象。 扩展：concurrent.futures.Future对象是基于线程池/进程池实现异步操作时用到的对象 8、asyncio异步迭代器 9、 异步上下文管理器 10、 uvioopuvioop是asyncio的事件循环的替代方案 import asyncio, uvioop asyncio.set_event_loop_policy(uvloop.Eventlooppolicy()) 第七章、异步爬虫一、 异步爬虫：爬虫并行的访问url，实现高效的数据爬取1、异步爬虫的方式: --多线程，多进程： 优点：可以为相关阻塞的操作，单独开启线程或进程，阻塞操作就可以异步执行。 缺点：无法无限制的开启多线程或者多进程。 --线程池，进程池： 优点：可以降低系统对线程/进程创建和销毁的频率，从而降低系统的开销。 缺点：池中的线程/进程的数量有上限。 2、单线程 + 异步协程 event_oop:事件循环，相当于一个无限循环， 我们可以把一些函数注册 到这个事件循环上， 当满足某些条件的时候，函数就会被循环执行。 coroutine:协程对象，我们可以将协程对象注册到事件循环中，它会被事件循环调用。 我们可以使用async 关键字来定义一个方法，这个方法在调用时不会立即被执行，而是返回一个协程对象。 task: 任务，它是对协程对象的进一步封装，包含了任务的各个状态。 future: 代表将来执行或还没有执行的任务，实际上和task 没有本质区别。 async: 定义一个协程。 await: 用来挂起阻塞方法的执行。 3、 多任务协程 使用aiohttp模块中基于ClientSession类的Session对象,进行网络请求的发送 1.创建协程函数 2.创建session对象 3.进行网络请求，并获取响应数据 发起网络请求： get()/post() 封装参数: headers,params/data,proxy='http//ip:port' 使用await，对asyncio中的阻塞操作进行手动挂起 text()返回的是字符串形式的响应数据 read()返回的是二进制形式的响应数据 json()返回的是json对象 注意：获取响应数据之前一定要使用await进行手动挂起 在异步网页请求中，只要遇到要等待的代码就需要手动挂起 4.创建任务列表 5.调用协程函数()，并返回一个的协程对象,但函数内部的代码不会执行 6.创建一个future对象 7.将任务对象添加到任务列表中 8.创建一个事件循环对象 9.将存放多个任务对象的任务列表封装到wait中，并注册到loop中，并启动loop 第八章、selsnium模块一、selenium简介1、selenium模块的概念：基于浏览器自动化的一个模块 2、selenium模块的作用：能更便捷的获取网站中动态加载的数据，能更便捷的实现模拟登录 3、selenium模块的使用流程： 实例化一浏览器对象 编写基于浏览器自动化的操作代码 发起请求：get(url) 标签定位：find系列的方法 标签交互：send_keys('xxx') 执行js程序：excute_script('jsCode') 前进：forward() 后退：back() 点击：click() 关闭浏览器：close() 二、selenium基本操作1、使用webdriver调用浏览器驱动器 from selenium import webdriver driver = webdriver.Firefox(executable_path=r'D:\\pycharm\\pythongeckodriver\\geckodriver.exe') 2、获取请求网页 driver.get(url) 3、返回网页加载出来的html html = driver.page_source 4、关闭浏览器 driver.close() 5、设置隐式窗口 from selenium import webdriver from selenium.webdriver.firefox.options import Options 隐藏窗口 Options = Options() Options.add_argument('--headless') 使用webdriver调用浏览器， driver =webdriver.Firefox(options=Options, executable_path=r'D:\\geckodriver.exe') 三、selenium常用函数1、定位元素 1） 根据class定位 element = driver.find_element_by_class_name('要定位的标签') 根据css定位 element = driver.find_element_by_css_selector('要定位的标签') 根据id定位 element = driver.find_element_by_id('要定位的标签') 根据链接的文本定位 element = driver.find_element_by_link_text('要定位的标签') 根据节点名定位 element = driver.find_element_by_name('要定位的标签') 根据根据链接的文本定位 element = driver.find_element_by_partial_link_text('要定位的标签') 根据tag定位 element = driver.find_element_by_tag_name('要定位的标签') 根据xpath定位 element = driver.find_element_by_xpath('要定位的节点') 2） 将element改为elements会定位所有符合条件的元素，返回一个列表。 例如: eb会返回一个WebElement对象 element = driver.find_elements_by_class_name('要定位的标签') 3） 提取WebElement对象的信息 获取属性：element.get_attribute() 获取文本：element.text 获取标签名：element.tag_name 获取节点id：element.id 2、鼠标动作 from selenium.webdriver import ActionChains # 实例化一个动作链对象 action = ActionChains(driver=driver) # 单击某个节点 action.click(on_element=element1) # 单击某个节点，并按住不放 action.click_and_hold(on_element=element1) # 右键单击某个节点 action.context_click(on_element=element1) # 双击某个节点 action.double_click(on_element=element1) # 将某个节点拖拽到另一个节点上 action.drag_and_drop(source=element1, target=element2) # 按住某个节点，沿着X轴和Y轴方向拖拽特定距离 action.drag_and_drop_by_offset(source=element1, xoffset=10, yoffset=20) # 按下特殊键：Ctrl、Alt、Shift action.key_down(value=\"Ctrl\", element=element1) # 释放特殊键 action.key_up() # 鼠标从当前位置移动到某个坐标 action.move_by_offset(xoffset=10, yoffset=10) # 鼠标移动到某个元素 action.move_to_element(to_element=element1) # 移动到距某个元素（左上角坐标）多少距离的位置action.move_to_element_with_offset(to_element=element1, xoffset=10, yoffset=10) # 执行链中的所有动作 action.perform() # 在某个元素位置松开鼠标左键 action.release(on_element=None) # 发送某个键到当前焦点的元素 action.send_keys(keys_to_send=) # 发送某个键到指定元素 action.send_keys_to_element(element=element1, keys_to_send=) # 重置操作 action.reset_actions() 3、弹窗 实例化弹窗对象 alert = driver.switch_to_alert() 确定 alert.accept() 关闭对话框 alert.dismiss() 传入值 alert.send_keys() 获得对话框 alert.text() 4、页面的前进、后退、切换 打开页面 driver.get('https://www.baidu.com') # 页面回退 driver.back() # 页面前进 driver.forward() 5、页面截图 driver.save_screenshot(\"截图.png\") 6、页面等待 from selenium import webdriver from selenium.webdriver.support.ui import WebDriverWait driver=webdriver.Firefox(executable_path=r'D:\\pycharm\\pythongeckodriver\\geckodriver.exe') element = WebDriverWait(driver,10) 7、执行JS语句 driver.execute_script(js语句) 1）滚动到底部 js = document.body.scrollTop=10000 driver.execute_script(js) 8、Cookies操作 获取Cookices driver.get_cookies() 增加Cookices driver.add_cookice({\"Cookie\": \"sid=***\"}) 删除Cookices driver.delete_cookie() 9、selenium处理iframe + 动作链1）如果定位的标签在iframe中，需要先切换浏览器的作用域：driver.switch_to.frame(‘iframe标签，id’)2）动作链（拖动）： 导入模块： from selenium.webdriver import ActionChains 实例化一个动作链对象： action = ActionChains(driver) 点击且长按指定的标签： action.click_and_hold('div') 拖动标签：x是水平方向，y是竖直方向 .move_by_offset(x,y) 立即执行动作链： perform() 释放动作链： action.release() 三、selenium的静态浏览器和规避检测 2、实现隐藏窗口,(静态浏览器，无可视化界面) 导入Options库 from selenium.webdriver.firefox.options import Options 实现规避检测 from selenium.webdriver import ChromeOptions 实例化Options,实现隐藏窗口,(静态浏览器，无可视化界面) firefox_options = Options() firefox_options.add_argument('--headless') firefox_options.add_argument('--disable-gpu') 实例化ChromeOptions,实现规避检测 option = ChromeOptions() option.add_experimental_option('excludeSwitches',['enable-automation']) 实例化一个浏览器对象，用webdriver调用浏览器，并导入驱动程序路径,实现隐藏窗口,实现规避检测. driver = webdriver.Firefox(executable_path=r'D:\\pycharm\\python_geckodriver\\geckodriver.exe',options=option,firefox_options=firefox_options) 第九章、抓包一、简介1、抓包：通过浏览器抓取动态页面返回的数据包。 2、流程： 打开浏览器搜索信息，单击右键，选择检查，点击网络，在网络中找到传输到动态页面的数据包，复制URL、请求头数据、响应数据。对着URL进行网络请求，并将请求头数据添加到headers中，将响应数据添加到params/data中。 二、获取简书动态页面的标题第一步：先获取json数据包的URL，请求头数据，响应数据 第二步：导入库 import requests import json import re 第三步：URL、请求头、携带参数 url = “https://www.jianshu.com/c/V2CqjW?order_by=added_at&amp;page=1\" 请求头： headers = { \"Accept\": \"text/html, */*; q=0.01\", \"Accept-Encoding\": \"gzip, deflate, br\", \"Accept-Language\": \"zh-CN,zh;q=0.9,en;q=0.8,en-GB;q=0.7,en-US;q=0.6\", \"Connection\": \"keep-alive\", \"Cookie\": \"_ga=GA1.2.1967223958.1615384892; __yadk_uid=xzfkyB9xewiiKaJbp24ZqzC3VhN6UUhJ; efault_font=font2;Hm_lvt_0c0e9d9b1e7d617b3e6842e85b9fb068=1622858975,1623502154,1624174201,1624620785; Hm_lpvt_0c0e9d9b1e7d617b3e6842e85b9fb068=1624620797\", \"Host\": \"www.jianshu.com\", \"Referer\": webpath1, \"sec-ch-ua\": '\" Not;A Brand\";v=\"99\", \"Microsoft Edge\";v=\"91\", \"Chromium\";v=\"91\"', \"sec-ch-ua-mobile\": \"?0\", \"Sec-Fetch-Dest\": \"empty\", \"Sec-Fetch-Mode\": \"cors\", \"Sec-Fetch-Site\": \"same-origin\", \"User-Agent\": \"Mozilla/5.0 (Windows NT 10.0; Win64; x64) 4.59\", \"X-CSRF-Token\": \"LuQ/84M8/68ZYCRrUYU84GzDWMqk8YCgvq0w/9Res1iIbzFO8ObDQw==\", \"X-INFINITESCROLL\": \"true\", \"X-Requested-With\": \"XMLHttpRequest\", } 携带参数： params = { \"order_by\": \"added_at\", \"page\": 1, } 第四步、向URL发起网络请求，获取页面数据，将其转换成二进制形式，并忽略乱码。 response = requests.get( url=url, headers=headers, params=json.dumps(params), ).content.decode('utf-8','ignore') 参数： 将字典类型的参数转换成json格式：json.dumps(params) 将响应数据转换成二进制形式：.content 忽视二进制乱码：.decode('utf-8','ignore') 第五步：使用正则，提取response对象中的标题 title = re.findall('&lt;div class=\"content\"&gt;[\\s\\S]+?&lt;a class=\"title\" target=\"_blank\" href=\".*?\"&gt;(.*?)&lt;/a&gt;[\\s\\S]+?&lt;p class=\"abstract\"&gt;', response, re.S) 第六步：将数据存储 with open(file_path, \"a\", encoding=\"utf8\") as fp: fp.write(title + \"/n\")","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://yanjiuzhe.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanjiuzhe.github.io/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://yanjiuzhe.github.io/tags/%E7%88%AC%E8%99%AB/"}],"author":"书生"},{"title":"python程序设计","slug":"python程序设计","date":"2021-08-19T07:57:26.000Z","updated":"2021-08-19T08:35:15.275Z","comments":true,"path":"posts/dd5b5f9c.html","link":"","permalink":"https://yanjiuzhe.github.io/posts/dd5b5f9c.html","excerpt":"","text":"Python学习​ –python编程从入门到实践笔记 第一章、变量和基本数据类型一、变量：变量是一种可以赋给值的标签。值在内存有一个存放空间，将变量贴在空间上，就能使变量指向那个值。 整型变量：mes = 1 浮点型变量：mes = 1.5 字符串变量：mes = \"你好，python\" 2、变量名的命名规则变量名只能由字母，数字和下划线组成，且数字不能在首位。关键字不能作为变量名。 二、基本数据类型 1）数值类型 整型： int 1 浮点型：float 1.5 复数型：complex 布尔型：bool True/False 2）序列类型 字符串：string \"你好，python\" 列表：list [1,2,3] 元组：tuple (1,2,3) 字典：dict {a:1} 集合：set {1,2,3,4} 三、常量常量名大写，常量的值始终不变 MAX = 5000 四、运算符算数运算符：+ - * / % ** //比较运算符：&lt; &gt; &lt;= &gt;= == !=逻辑运算符：and or not赋值运算符：= += -= *= /= %= **= //=成员运算符：in not in身份运算符：is not is 五、关键字 False 假 None 无 True 真 and 与 or 或 not 非 as 取别名 assert break 退出当前循环 class 创建类 continue退出本次循环 def 创建函数 del 删除 if 如果 elif 在如果 else 否则 while 当循环 for 循环 in 判断一个变量是否在另一个变量里面 is 比较两个变量的内存地址 try except finally pass 占位符 return 将值返回 raise from 来自 import 导入模块 global 全局的，定义全局变量 nonlocal lambda 匿名函数 with yield 将迭代的值返回 7、注释：单行注释：//多行注释：’’’ ‘’’ 或 “”” “”” 或 8、强制类型转换能强制类型转换 int和float list,tuple和set bool和intint() 8、python通过缩进和”:”冒号，区分代码之间的层级 第二章、数据类型及其操作一、字符串类型及其操作1.字符串定义：字符串是字符组成的序列，由单引号/双引号/三引号括起来的。2.转义字符”\"，r让转义字符不生效3.字符串的索引和切片,字符串通过下标索引和切片，下标从0开始，到序列的前一位。4.索引 正向索引 \"hello\"[1] \"e\" 逆向索引，可以使用-1索引最后一位元素 \"hello\"[-1] \"o\" 5.切片第一种，切片 // 截取下标0-2的字符串 \"hello\"[0:2] 结果：\"hel\" 第二种：步长切片 // 截取下标0-5的字符串，每次个两位下标截取。 \"hello\"[0:5:2] 结果：\"hl\" 6、字符串的格式化format() name=jk a = f\"hello {name}\" b = \"hello {}\".format(0=\"tom\") 7.字符串函数修改字符串大小写首字母大写：string.title()全部字母大写：string.upper()全部字母小写：string.lower() 删除字符串空白删除开头空白：string.rstrip()删除末尾空白：string.lstrip()删除两端空白:string.strip() 8、join()“”.join(序列) 将序列以” “连接，用于合并序列的元素。 9、split()“”.split(“/“) 将序列以”\"分割，用于将字符串拆分为序列。 center()：通过在两边添加填充字符（默认为空格）让字符串居中good = “hello”print(good.center(10, “*”)) find()在字符串中查找子串。如果找到，就返回子串的第一个字符的索引，否则返回-1。good = “hello world”print(good.find(“hello”)) replace()将指定子串都替换为另一个字符串，并返回替换后的结果 good = \"hello world\".replace(\"hello\", \"***\") print(good) *** world 二、数值类型及其操作整型和浮点型：加，减，乘，除，乘方 三、列表类型及其操作1.列表的索引，列表通过下标索引 color = [\"red\", \"blued\", \"green\", \"black\"] print(color[0]) red 列表的切片 color = [\"red\", \"blued\", \"green\", \"black\"] print(color[1:3]) [\"blued\", \"green\"] 遍历切片data = [1,2,3,4,5,6,7,8,9]for i in data[:7]: print(i) 复制列表同时省略起始索引和终止索引：[ : ] color = [\"red\", \"blued\", \"green\", \"black\"] a_color = color[ : ] print(a_color) [\"red\", \"blued\", \"green\", \"black\"] 2.列表的修改、添加、删除(1).修改列表元素直接索引，然后直接重新赋值 color = [\"red\", \"blued\", \"green\", \"black\"] color[0] = \"yellow\" print(color) [\"yellow\", \"blued\", \"green\", \"black\"] (2).添加列表元素使用append()，在列表末尾添加元素：list.append(“volue”) color = [\"red\", \"blued\", \"green\", \"black\"] color.append(\"yellow\") print(color) ['red', 'blued', 'green', 'black', 'yellow'] 使用insert()，在列表中插入元素，需要指定新元素的索引和值：list.insert(0, “value”) color = [\"red\", \"blued\", \"green\", \"black\"] color.insert(0, \"yellow\") print(color) ['yellow', 'red', 'blued', 'green', 'black'] (3).删除列表元素使用del删除元素：del color[0] color = [\"red\", \"blued\", \"green\", \"black\"] del color[0] print(color) [\"blued\", \"green\", \"black\"] 使用clear()清空列表 color.clear() [] 使用pop()删除元素pop()可以弹出任何位置的元素，只需在圆括号中指定元素的索引 color = [\"red\", \"blued\", \"green\", \"black\"] color = color.pop(0) print(color) \"red\" 使用remove()，根据值删除删除元素 color = [\"red\", \"blued\", \"green\", \"black\"] color.remvoe(\"red\") print(color) [\"blued\", \"green\", \"black\"] 3.组织列表(1).使用sort()对列表永久排序按照字母永久顺序排序 color = [\"red\", \"blued\", \"green\", \"black\"] color.sort() print(color) ['black', 'blued', 'green', 'red'] 使用sort()对列表永久逆序排序 color = [\"red\", \"blued\", \"green\", \"black\"] color.sort(reverse=True) print(color) ['red', 'green', 'blued', 'black'] (2).使用sorted()函数对列表临时排序 color = [\"red\", \"blued\", \"green\", \"black\"] print(sorted(color)) ['black', 'blued', 'green', 'red'] 使用sorted()函数对列表临时逆序排序 color = [\"red\", \"blued\", \"green\", \"black\"] print(sorted(color,reverse=True)) ['red', 'green', 'blued', 'black'] (3).使用reverse()方法，反转列表元素的顺序 color = [\"red\", \"blued\", \"green\", \"black\"] color.reverse() print(color) ['black', 'green', 'blued', 'red'] 4.使用len()函数，返回序列的长度 color = [\"red\", \"blued\", \"green\", \"black\"] print(len(color)) 4 5.使用for遍历列表 color = [\"red\", \"blued\", \"green\", \"black\"] for i in color: print(i) red blued green black 6.使用range()函数，创建数集(1).range()函数的基本使用函数range()的三种使用方法，range(5)设定范围，range(1,5)设定区间，range(1,5,2)设定区间和步长 for i in range(5): print(i) 0 1 2 3 4 (2).使用range()，创建数字列表 number_list = list(range(1,10)) print(number_list) [1, 2, 3, 4, 5, 6, 7, 8, 9] 7.使用列表函数，对数字列表进行统计 data = [1,2,3,4,5,6,7,8,9] max_a = max(data) # 返回列表最大值 min_b = min(data) # 返回列表最小值 sum_c = sum(data) # 返回列表的和 count_d = daat.count(1) # 返回列表元素出现的次数 index_e = data.index(1) # 返回列表元素第一次出现的索引 8.列表解析 squares = [i**2 for i in range(1,11)] print(squares) 四、元组类型及其操作元组的值是不可修改的，但可以重新定义定义元组：tuple = (1,2,3)修改元组变量：tuple = (1,2,3)tuple = (4,5,6) 五、字典类型及其操作字典由一对键值对组成，可以通过键来访问值一、简单字典定义字典：dict = {1:”green”, 2:”yellow”, 3:”red”}访问字典的值：dict[1]使用get()访问字典的值：第一个参数是键，第二个参数是当指定的键不存在时返回的值 dict = {1:”green”, 2:”yellow”, 3:”red”}dict.get(“1”, “此键不存在”) 二、字典的键值对的添加、修改、删除1.添加键值对，指定字典的名，键，值：dict[4] = “black” dict = {1:”green”, 2:”yellow”, 3:”red”}dict[4] = “black”print(dict){1: ‘green’, 2: ‘yellow’, 3: ‘red’, 4: ‘black’} 2.修改键值对，指定字典的名，键，新值：dict[1] = “black” dict = {1:”green”, 2:”yellow”, 3:”red”}dict[1] = “black”print(dict){1: ‘black’, 2: ‘yellow’, 3: ‘red’} 3.使用del，删除键值对 dict = {1:”green”, 2:”yellow”, 3:”red”}del dict[1]print(dict){2: ‘yellow’, 3: ‘red’} 四、遍历字典(1).遍历所有的键值对 dict = {1:”green”, 2:”yellow”, 3:”red”}for k, v in dict.items(): print(f”键={k} \\n值={v}”) (2).遍历字典中的所有键 dict = {1:”green”, 2:”yellow”, 3:”red”}for k in dict.keys(): print(f”键={k}”) (3).遍历字典中的所有值 dict = {1:”green”, 2:”yellow”, 3:”red”}for v in dict.values(): print(f”值={v}”) 五、字典的嵌套1.字典列表：在列表中嵌套字典list = [{1:”green”}, {2:”red”}, {3:”blue”}] 2.列表字典：在字典中嵌套列表dict = {“colors”:[“red”, “green”, “blue”,], “letter”:[“a”, “b”, “c”]} 3.在字典中嵌套字典dict = {“number”:{1:”one”, 2:”two”, 3:”three”}, “letter”:{“a”:”A”, “b”:”B”, “c”:”C”}} 第三章、选择结构一、条件测试if语句的核心是一个值为True或False的表达式，这种表达式称为条件测试。1.使用==，测试是否相等 2.使用!=，测试是否不相等 3.使用比较运算符，进行数值的比较&lt; &gt; &lt;= &gt;= == != 4.使用and和or，进行检查多个条件 5.使用in，检查特定的值是否包含在列表中 6.使用not in，检查特定的值是否不包含在列表中 7.布尔表达式 二、选择结构1、if语句 //if语句：如果条件成立，就执行语句，条件不成立，就不执行语句 age = int(input(\"请输入年龄：\")) if age &lt; 18: print(\"未成年\") 2、if-else语句 //if-else语句：如果条件成立，就执行语句1（print(\"未成年\")），否则就执行语句（print(\"已成年\")） age = int(input(\"请输入年龄：\")) if age &lt; 18: print(\"未成年\") else: print(\"已成年\") 3、if-elif-else结构语句 //if-elif-else：如果条件1成立就执行语句1，不成立就在判断条件2，成立就执行语句2，否则就执行语句3 age = int(input(\"请输入年龄：\")) if age &lt; 18: print(\"少年\") elif age &gt;= 18 and age &lt; 65: print(\"成年人\") else: print(\"老年人\") 三、循环结构1、while循环一、简单while循环 num = 0 while num &lt; 10: print(num) 结果：0,1,2,3,4,5,6,7,8,9 二、让用户选择退出 //可以让程序死循环，设定一个退出值，用户输入退出值，则结束程序。 age = 1 while age != -1: age = int(input(\"请输入年龄：\")) if age &lt; 18: print(\"少年\") elif age &gt;= 18 and age &lt; 65: print(\"成年人\") else: print(\"老年人\") 三、标志在要满足很多要求，才会继续运行程序时，可以设定一个变量，用于判断程序是否在运行。将所有测试条件放在变量中。 四、退出循环1.退出当前循环：break2.跳过本次循环：continue 五、使用while循环处理列表和字典(1).删除列表里的特定元素data = [“a”, “b”, “c”, “d”,”a”]while “a” in data: data.remove(“a”)print(data) (2).使用用户的输入来填充字典dic_data = {}flog = Truewhile flog: name = input(“你的名字：”) answer = input(“你对阿富汉与叙利亚的第四次宗教与文化的战争冲突怎么看？\\n”) dic_data[name] = answer a = input(\"那你呢？(yes/no)\\n\") if a == \"no\": flog = False for name, answer in dic_data.items(): print(f”{name}: {answer}”) 第四章、函数一、基本函数1、简单函数 // 使用关键字def定义函数，在main中进行调用。 def hello(): print(\"你好\") if __name__ == \"__main__\": hello() 2、设置函数的形参(1)、给函数设定形参，调用函数的时候输入实参，传入参数的时候可以直接关联形参和实参。(2)、在设定形参的时候可以设定必选参数和可选参数，可选参数要放在必选参数的后面。并且可以设置参数的默认值。 例子：// 定义一个函数，设置形参，有必选形参和可选形参，必选形参默认值是python。 def hello(name=\"python\"，*age): print(f\"你好, {name}\") if __name__ == \"__main__\": hello(name=\"唐三\") 3、向函数传递列表直接把列表当成值传递就行 def hello(names,age=0): for name in names: print(f\"你好, {name}\") if __name__ == \"__main__\": name = [\"唐三\", \"萧炎\", \"林动\", \"冻千秋\"] hello(names=name) 4、传递任意数量的实参，在设定形参的时候，带上*。 def hello(*names): for name in names: print(f\"你好, {name}\") if __name__ == \"__main__\": hello(\"唐三\", \"萧炎\", \"林动\", \"冻千秋\") 5、设置函数的返回值在函数里可以使用return返回一个值，可以在函数调用处使用变量接收这个值 def hello(name): good = f\"你好, {name}\" print(good)， return good 二、函数可以作为列表元素使用// 定义三个函数，将函数名放入列表，列表索引加上()就能调用函数 def func1(): print(\"盖亚！\") def func2(): print(\"迪迦！\") def func3(): print(\"艾斯！\") list_ = [func1, func2, func3] // 函数名加上括号就是调用 list_[0]() // 遍历执行函数 for f in list_: f() 结果：盖亚！ 迪迦！ 艾斯！ 三、函数的嵌套(闭包)函数里面还可以创建函数，并还可以使用return将函数返回，实现了内部函数在外部的访问。闭包：保护变量不被其他变量侵害，保持一个变量常驻内存。 def func(): name = \"法外狂徒\" def funca(): return name return funca r = func() print(r()) 四、函数可以作为参数进行传递def funca(): print(\"灌汤包\") def funcb(): print(\"叉烧包\") def func(x,y): x() y() func(funca, funcb) 五、将函数存储在模块将函数存储在独立的文件中，在使用import导入到主程序中1.导入模块：import 模块名2.导入特定函数(可以用逗号隔开，同时到导入多个特定函数)：from 模块名 import 函数名3.使用as给函数取别名：from 模块名 import 函数名 as 新函数名4.使用as给模块取别名：import 模块名 as 新模块5.使用*导入模块中的所有函数：for 模块名 import * 六、lambda函数：匿名函数1、匿名函数 lambda表达式 f = lambda x,y:x+y print(f(1, 2)) 2、lambda表达式的一个应用 // 三元表达式 x, y = 2, 1 r = x if x &gt; y else y print(r) // 可以将三元表达式放入匿名函数中，突破匿名函数不能放代码块的限制 f = lambda x,y:x if x &gt; y else y print(f(1, 2)) 七、python内置函数关于基本数据类型的函数 1、强制数据类型转换的函数 int() 将浮点数强制转换成整型 float() 将整型强制转换成浮点型 bool() str() 强制转换成字符串 tuple() 强制转换成元组 set() 强制转化成集合 list() 强制转换成列表 2、进制转换 bin() 将数据转换成二进制 oct() 将数据转换成八进制 hex() 将数据转换成十六进制 3、数学运算 sum() 对可迭代对象求和 max() 返回可迭代对象最大值 min(12,13) 返回可迭代对象最小值 pow() 求次方 round() 四舍五入 divmod() 求商和余数 4、关于数据结构的函数 len() 返回序列长度 all() 查看序列中的真和假，and sorted() 给序列临时排序，key:排序规则，reverse:正序/逆序 filter() 过滤 zip() zip，它将两个序列“缝合”起来，并返回一个由元组组成的序列。返回值是一个适合迭代的对象，要查看 其内容，可使用list将其转换为列表当序列的长度不同时，函数zip将在最短的序列用完后停止“缝合”。 5、序列 reversed() 将序列反转 format() 字符串格式化 关于迭代器和生成器的函数 range() 1、迭代数字的，能够生成数字序列 iter() 2、获取迭代器，迭代器一定可以迭代 next() 3、获取一个迭代内容， 关于作用域的函数 locals() 1、查看当前位置的全部全局变量 globals() 2、字典的类型返回全部的全局变量 其他内置函数 1、将内容打印到屏幕或文件，end:结束符，sep:分隔符，file:打印的文件地址 print(\"hello\",\"world\", end=\" \", sep=\"*\") input() 2、从键盘上输入，可以加一个提示信息 eval() 3、执行字符串类型的代码，并返回结果 id() 4、查看变量所指的内存地址 dir() 5、查看数据类型的操作 open() 6、打开文件 hash() 7、可以进行hash算法，返回一串数字。 help() 8、查看源码 callable() 9、查看是否可调用 join() 10、\"\".join(序列) 将序列以\" \"连接，用于合并序列的元素。、 split() 11、\"\".split(\"/\") 将序列以\"\\\"分割，用于将字符串拆分为序列。 exit()： 结束程序 type()： 查看变量的数据类型 find() str.find(\"东京\")检测字符串中是否包含子字符串，如果指定 beg（开始） 和 end（结束） 范围， 则检查是否包含在指定范围内，如果包含子字符串返回开始的索引值，否则返回-1。 第五章、生成器、迭代器、装饰器第一部份、迭代器dir()可以查看数据可以执行的操作 方法一、判断可迭代对象和迭代器 print(dir(int)) 没有'__iter__' print(dir(bool)) 没有'__iter__' print(dir(str)) 有'__iter__' print(dir(list)) 有'__iter__' print(dir(dict)) 有'__iter__' print(dir(set)) 有'__iter__' print(dir(tuple)) 有'__iter__' 得出，有__iter__就是可迭代对象 for进行遍历，先判断是否是迭代对象，在去拿迭代器，执行next()进行迭代。 方法二、判断可迭代对象和迭代器 判断是否是可迭代的和迭代器：Iterable：可迭代类型的，Iterator：迭代器 from collections.abc import Iterable,Iterator list_ = [\"路飞\",\"索隆\",\"娜美\",] print(isinstance(list_,Iterable)) # 判断list_是否是可迭代类型 True print(isinstance(list_,Iterator)) # 判断list_是否是迭代器 False 获取迭代器，迭代器一定可以迭代 it = list_.__iter__() print(isinstance(it,Iterable)) # 判断list_是否是可迭代类型 True print(isinstance(it,Iterator)) # 判断list_是否是迭代器 True for el in it: print(el) 结果：\"路飞\" \"索隆\" \"娜美\" 第二部分、生成器一、生成器：本质是迭代器，创建是生成器的方式：生成器函数、通过生成器表达式来获取生成器、类型转换。 函数中包含yield，此函数就是生成器函数。生成器函数运行后返回的是一个生成器，而不是运行函数。 // 创建生成器函数，调用生成器函数，返回的是迭代器。 def func(): print(\"第一步\") yield \"返回1\" # yield表示返回，不会终止函数 print(\"第二步\") yield \"返回2\" ret = func() print(\"返回值：\",ret) # 返回值： &lt;generator object func at 0x0000027DEE7775F0&gt; print(ret.__next__()) print(ret.__next__()) print(ret.__next__()) for i in ret.__next__(): print(i) 二、使用生成器生成数据 所有的生成器都可以直接使用for循环，所有的生成器都可以使用lis()来获取生成器内的所有数据。 // 创建生成器函数，并循环使用yield返回数据，使用list()获取数据 def buy(): for i in range(1000): yield f\"{i}战机\" gen = buy() print(list(gen)) [1战机 2战机 3战机 4战机 5战机.....] 三、生成器向下执行的两个方法： 1、next()，使生成器执行到下一个yield 2、send()给上一个yield位置传值，并使生成器向下执行 def func(): print(\"喜羊羊\") a = yield \"灰太狼\" print(\"a=\",a) b = yield \"红太狼\" print(\"b=\",b) c = yield \"小灰灰\" print(\"c=\",c) gen = func() print(gen.__next__()) print(gen.send(\"篮球\")) print(gen.__next__()) print(gen.send(\"足球\")) 第三部分、装饰器一、装饰器开闭原则，对功能的扩展开放、对代码的封闭修改、在目标函数的前后添加代码，并且不改变原来的代码 // 装饰器函数 def wrapper(fn): # fn是目标函数 def inner(*args, **kwargs): # 为了目标函数的传参 print(\"打开外挂\") ret = fn(*args, **kwargs) # 调用目标函数，ret是目标函数的返回值 print(\"关闭外挂\") return ret # 八目标函数返回值返回，保证函数的正常结束 return inner // 使用装饰器函数装饰目标函数 @wrapper def play(): print(\"启动王者荣耀\") // 调用目标函数 play() 二、带参数的装饰器 // 在装饰器函数上再套一层装饰器 def wrapper_out(flag): # 装饰器本身的参数 def wrapper(fn): # fn是目标函数 def inner(*args, **kwargs): # 为了目标函数的传参 if flag: print(\"打开百年孤独\") ret = fn(*args, **kwargs) # 调用目标函数，ret是目标函数的返回值 print(\"关上百年孤独\") return ret # 八目标函数返回值返回，保证函数的正常结束 else: ret = fn(*args, **kwargs) # 调用目标函数，ret是目标函数的返回值 return ret # 八目标函数返回值返回，保证函数的正常结束 return inner return wrapper // 使用装饰器函数装饰目标函数 @wrapper_out(True) def read(): print(\"阅读百年孤独\") read() 三、同一个函数被多个装饰器装饰 装饰器会按就近原则，装饰目标函数 def wrapper1(fn): def inner(*args, **kwargs): print(\"111\") ret = fn(*args, **kwargs) print(\"one\") return ret return inner def wrapper2(fn): def inner(*args, **kwargs): print(\"222\") ret = fn(*args, **kwargs) print(\"two\") return ret return inner def wrapper3(fn): def inner(*args, **kwargs): print(\"333\") ret = fn(*args, **kwargs) print(\"three\") return ret return inner // 装饰目标函数 @wrapper3 @wrapper2 @wrapper1 def eat(): print(\"干饭\") eat() 第六章、面向对象一、创建和使用类1. 创建类、 class Animal: (1).构造方法：__init__()，初始化属性，并设置属性的默认值，当使用类来创建实例的时候，python会自动运行它。在创建实例时，通过self传递实参。 def __init__(self, name=\"\", age=0): (2).# 设置属性：属性是带self的变量，该变量可以在类的所有方法中使用，可以通过类的实例来访问该变量。 self.name = name self.age = age (4).在类里定义方法 def sit(self): print(f\"{self.name}，坐下\") def roll(self): print(f\"{self.name},打滚\") 2.创建实例、访问属性、调用方法 if __name__ == \"__main__\": 创建实例 my_Animal = Animal(\"来福\", 12) 通过实例来访问属性：实例.属性 animal_name = my_Animal.name print(dog.name) print(my_Animal.dong) 通过实例，调用类里的方法：实例.方法 my_Animal.sit() my_Animal.roll() 3、修改属性的值(1).直接修改属性的值 通过实例访问属性，在重新赋值。 例：my_dog.dong = \"打滚\" (2).通过方法修改属性的值 就是在类里面定义一个方法，调用方法，传入参数并修改属性 class Dog: --snip-- def modify(self, mil): self.dong = mil if __name__ == \"__main__\": my_dog = Dog(\"来福\", 12) my_dog.modify(\"打滚\") (3).通过方法对属性的值进行递增 就是在类里面定义个方法，对属性进行修改 class Dog: --snip-- def modify(self, mil): self.age += mil if __name__ == \"__main__\": my_dog = Dog(\"来福\", 12) my_dog.modify(3) 二、类的封装将固定的功能封装到一个代码块：对功能的封装、对属性的封装。 class Animal(): # 1、对属性的封装 def __init__(self,name): self.name = name # 2、对方法和功能的封装 def run(self): print(\"跑\") 二、类的继承继承：一个类继承另一个类的全部的属性和方法，同时还可以定义自己的属性和方法。（原有的类称为父类，新的类称为子类） 1、子类继承父类子类自动继承父类的中除了私有内容外的其他所有内容，使用init()接收父类的全部参数，使用super()包含父类的全部属性。 # 1）创建父类 class Animal(): # 对属性的封装 def __init__(self,name): self.name = name # 对方法和功能的封装 def run(self): print(\"跑\") # 2）父类Animal class Dog(Animal): # 定义构造方法：继承父类的属性，并自己扩展属性 def __init__(self, name, age): Animal.__init__(name) self.age = age # 扩展子类的方法 def eat(self): print(\"干饭\") # 3、创建对象，并调用父类的方法和自己的方法。 dog = Dog() dog.run() dog.eat() 2、覆盖：重写父类的方法就直接在子类里在写过一遍该方法，运行时，程序会忽略父类里的方法，转而运行子类里的该方法。 1、覆盖：子类中有与父类一样的方法，叫方法的覆盖 class Animal(): def run(self): print(\"跑\") # 2、继承父类Animal class Fish(Animal): # 将父类的run方法重写 def run(self): print(\"游泳\") fish = Fish() fish.run() 3、多继承：一个子类继承多个父类，当多个父类中有相同的方法，实行就近原则，先执行离当前类最近的父类。 第一个动物类 class Animal1(): def fly(self): print(\"飞翔\") 第二个动物类 class Animal2(): def run(self): print(\"散步\") 第三个动物类 class Animal3(): def run(self): print(\"奔跑\") 创建子类继承三个动物类 class Dragon(Animal1,Animal2,Animal3): pass 创建对象，并调用三个父类的方法 dragon = Dragon() dragon.fly() dragon.run() dragon.run() 四、类的多态同一个对象，有多种形态 1、将实例用作属性就是将子类里多余的方法，打包成一个类，并且在子类的属性中将其实例化 1、创一个父类 class Dog: # 定义一个__init__的方法，当使用类来创建实例的时候，python会自动运行它。在创建实例时，通过self传递实参。 def __init__(self, name): # 设置属性：属性是带self的变量，该变量可以在类的所有方法中使用，可以通过类的实例来访问该变量。 self.name = name self.dong = \"蹲下\" # 定义名为sit的方法 def sit(self): print(f\"{self.name}，坐下\") def roll(self): print(f\"{self.name},打滚\") 2、创建类，接收子类里多余的方法 class Age: # 初始化属性 def __init__(self, age=12): self.age = age # 定义方法 def print_age(self): print(f\"该狗的年龄是：{self.age}\") 3、建立一个子类，继承父类Dog的全部属性和方法，定义子类时必须在圆括号内指定父类的名称 class Dogson(Dog): 使用__init__()，接受创建Dog实例所需的参数 def __init__(self, name,): super()函数初始化父类属性，能在调动父类的__init__()方法时，能让子类的实例包含父类的的这个方法的所有 属性。 super().__init__(name) 4、将类实例化 self.age = Age() def run(self): print(\"向前奔跑\") 5.创建实例 if __name__ == \"__main__\": # 创建实例 my_dog = Dogson(\"来福\") # 调用方法： # 实例.方法 my_dog.run() # 实例.属性.方法 my_dog.age.print_age() 五、类的成员1、成员变量实例变量 对象.属性=xxx类变量 共享给该类所有的对象 类.变量 2、成员方法实例方法 对象.方法 def method(self): pass 类方法 类.方法 @classmethod def method(cls): pass 静态方法 类.方法 @staticmethod def method(): pass 3、成员私有以__开头的东西就是私有的，只能在自己的类里使用。 六、导入类1、导入单个类from 模块名 import 类名 2、在一个文件中导入多个模块from 模块名 import 类名, 类名, 类名 3、导入模块中的所有类from 模块名 import * 4、在一个模块中导入另一个模块 六、类与类的依赖关系1、创建person类 class person(): def play(self,tools): tools.run() print(\"开始玩游戏\") 2、创建phone类 class phone(): def run(self): print(\"打开手机\") 3、实例化phone类 ph = phone() 4、实例化person类 p = person() 5、调用person中的play方法，并将ph对象传进去，这两个类就产生了关系，这种关系叫依赖关系。 p.play(ph) 七、类与类的关联关系一对一的关系一对多的关系多对多的关系 八、selfself在访问方法的顺序，永远先找自己，在找父类。 九、supersuper() 函数是用于调用父类的一个方法。super() 是用来解决多重继承问题的，直接用类名调用父类方法在使用单继承的时候没问题，但是如果使用多继承，会涉及到查找顺序（MRO）、重复调用（钻石继承）等种种问题。MRO 就是类的方法解析顺序表, 其实也就是继承父类方法时的顺序表。 父类 class A: # 定义方法：将x+1在输出 def add(self, x): y = x + 1 print(y) 子类 class B(A): # 重写方法，使用super调用父类的add()方法 def add(self, x): super().add(x) 创建对象，并调用子类的add方法 b = B() b.add(2) 十、类的特殊成员十一、区分函数与方法1、在类中 类.方法 函数 对象.方法 方法2、类方法 都是方法3、静态方法 都是函数 十二、反射hasattr() 判断类中有没有这个方法 getattr() 将类中的方法取出 // 第一个类、bigcow模块 def a(): print(\"大牛干饭\") def b(): print(\"大牛喝水\") def c(): print(\"大牛睡觉\") // 第二个类 import bigcow action = input(\"请输入动作：\") if hasattr(bigcow, action): print(\"有这个动作\") xx = getattr(bigcow, action) xx() else: print(\"没有这个动作\") 第七章、文件操作、异常处理、MD5一、文件操作文件打开模式：【w: writer】 【r: read】 【t: text】 【b: 字节】 【a:追加】 【+：读写】 【seek(): 】 #open()打开文件 – 并实例化 – fp:文件权柄， open:打开， ‘test.txt’:文件路径， ‘r’：read 读，readlines():读一行, write: 写 第一种文件操作 #打开文件 fp = open('test.txt', 'r') #write()写入文件 fp = open('test.txt', 'r') fp.write('sb,sb,sb,sb') #read()读取文件 -- read()读 读取writer中全部文件，并赋给变量conten fp = open('test.txt', 'r') conten = fp.read() #readline()读取fp中的一行文件，并赋给conten fp = open('test.txt', 'r') conten = fp.readline() #close()关闭文件 fp.close() 第二种文件操作 写入文件 with open('test.txt', 'wb+') as fp: fp.write('aaa') fp.write(bytes('中国'.encoed('utf-8'))) 读取文件 with open('test.txt', 'r') as fp: conten = fp.read() 二、异常处理将代码放在try里，代码没错就正常运行，报错就查找与之匹配的except代码块运行 1、try-except2、try-except-else3、try-except-finally 1、简单错误处理 try: print(1/0) except: print(错误) 2、处理全部的错误：Exception try: print(1/10) except Exception: print(\"\") 3、专项错误专项处理，在加上一个所有错误兜底Exception。 try: print(1/0) except ZeroDivisionError: print(\"除以0错误\") except FileNotFoundError: print(\"文件不存在错误\") except Exception: print(\"其他错误\") else: # 当try中的代码没有错误，会自动执行else中的代码。 print(\"A\") finally: # 执行收尾工作的，不管程序出没出错，都会执行finally。 print(\"\") 4、手动抛异常 raise：异常类 def add(a,b): if type(a)==int and type(b)==int: return a+b else: raise Exception(\"我没办法处理这样的运算\") add(1,\"a\") 5、自己定义异常类 class culException(Exception): pass def cul(a,b): if type(a)==int and type(b)==int: return a+b else: raise culException(\"我没办法处理这样的运算\") cul(1,\"a\") 6、查看堆栈错误信息 查看堆栈信息的模块 import traceback try: print(1/0) except Exception: 查看堆栈信息 ​ ret = traceback.format_exc() ​ print(ret) ​ print(\"错误\") 7、实战：除法计算器 try: print(\"按q，退出程序\") while True: first_number = input(\"请输入除数：\") if first_number == \"q\": break second_number = input(\"请输入被除数：\") if second_number == \"q\": break answer = float(first_number) / float(second_number) print(answer) except ZeroDivisionError: print(\"除数不能是零\") except ValueError: print(\"不能输入字符\") else: print(\"错误\") 三、MD51、加密、不可逆 import hashlib # MD5对象、并加盐 obj = hashlib.md5(b\"dhdh\") # 将需要加密的内容进行编码，在交给md5， obj.update(\"闪耀的星空\".encode(\"utf-8\")) # 拿到密文 100ddd9ac065e9b205d61642e0930eea print(obj.hexdigest()) 2、md5应用 # 加密函数 def md5_(pwd): # MD5对象、并加盐 obj = hashlib.md5(b\"dhdh\") # 将需要加密的内容进行编码，在交给md5， obj.update(pwd.en-code(\"utf-8\")) # 返回密文 return obj.hexdigest() # ATM while True: user_ = \"8806\" pwd_ = \"e26f4fb452c7020ec8cf82d8c4c862fe\" print(\"\"\" —————————————————— 欢迎使用ATM —————————————————— \"\"\") user = input(\"请输入账号：\") pwd = input(\"请输入密码：\") if user==user_ and md5_(pwd)==pwd_: print(\"登录成功\") break else: print(\"账号或密码错误\") break 后续：python常用模块一、random 随机数模块import random # 随机生成0-1的区间的随机小数 print(random.random()) # 随机生成一个整数区间的随机数 print(random.randint(1,10000000)) # 随机生成一个小数区间的随机数 print(random.uniform(0,10)) # 返回给定范围的随机数 random.randrange() # 随机打乱序列的顺序 _list = [\"桔梗\",\"杀生丸\",\"犬夜叉\",\"四魂玉\"] random.shuffle(_list) print(_list) # 从列表中随机选择一个元素 list_ = [\"路飞\",\"索隆\",\"娜美\",\"摩纳斯\"] print(random.choice(list_)) # 从列表中随机指定个数的元素 list_ = [\"灰原哀\",\"柯南\",\"毛利小五郎\",\"小兰\"] print(random.sample(list_,2)) 二、time 时间模块import time # 获取时间戳 t = time.time() # 格式化时间：年月日：%Y-%m-%d 时分秒：%H:%M:%S 星期：%A t = time.strftime(\"%Y-%m-%d %H:%M:%S %A\") # 结构化时间 time.struct_time(tm_year=2021, tm_mon=7, tm_mday=6, tm_hour=15, tm_min=15, tm_sec=40, tm_wday=1, tm_yday=187, tm_isdst=0) t = time.localtime() print(t) print(t.tm_year) print(t.tm_mon) print(t.tm_mday) # 重点1：将时间戳转化成格式化时间 # 先将时间戳转化成结构化时间，再将结构化时间转化成格式化时间，在指定显示格式。 print(time.strftime(\"%Y-%m-%d %H:%M:%S\",time.localtime(time.time()))) # 重点2：将格式化时间转化成时间戳 # 先获取格式化时间，再将格式化时间转换成，按指定格式转换成结构化时间，再将结构化时间转换成时间戳 user_date = input(\"请输入一个时间，格式是：1970-01-01 08:00:00：\") print(time.mktime(time.strptime(user_date,\"%Y-%m-%d %H:%M:%S\"))) # 睡眠一秒 time.sleep(1) 三、collections 统计模块import collections # 统计序列中元素出现的次数（字符串、列表、字典、元组）、字典的键是唯一的 str_ = \"山有木兮木有枝，心悦君兮君不知\" s = collections.Counter(str_) print(s) # c = {\"a\":\"A\"} cc = collections.defaultdict(c) print(cc) # collections.OrderedDict() 四、json模块import json js = {\"a\":None,\"b\":True,\"c\":False,\"d\":\"闪耀的星空\"} # 1、将对象转换成json j = json.dumps(js,ensure_ascii=False) print(j) # 2、将json反序列化成对象 s = json.loads(j) print(s) # 3、将对象序列化成json写入文件，一个json文件只能写入一个json，要写入多个json需要将json添加到列表中，在将列表写入文件 with open(\"json文件.json\",\"w\", encoding=\"utf-8\") as fp: dict_ = {\"a\":None,\"b\":True,\"c\":False,\"d\":\"闪耀的星空\"} json.dump(dict_,ensure_ascii=False,fp=fp) # 4、把文件中的json内容反序列化成对象 with open(\"json文件.json\",\"r\", encoding=\"utf-8\") as fp: obj = json.load(fp=fp) print(obj) 五、os 系统模块# 针对操作系统的模块 import os # 创建多级文件夹 os.makedirs(\"/一级/二级/三级\") # 创建一个文件夹 os.mkdir(\"一级\") # 删除当前文件夹的所有空文件夹 os.removedirs(\"\\一级\\二级\\三级\") # 删除指定文件夹 os.rmdir(\"\\一级\") # 打印指定目录下的所有文件 os.listdir(\"\\\\\") # 删除一个文件，指定路径，文件名 os.remove() # 重命名文件夹/文件 os.rename() # 获取当文件/文件夹的信息 os.stat(\"\") # 获取当前工作目录的路径 os.getcwd() # os.path 和路径相关的 # 查看当前路径的绝对路径 os.path.abspath(\"\") # 查看文件或目录是否存在，存在返回True，不存在返回False print(os.path.exists(\"D:\\\\soft\")) # 在当前目录创建一个文件夹(CSDN)，如果当前目录有文件这个文件夹，就不创建，没有就进行创建。 if not os.path.exists('CSDN'): os.mkdir('D:\\CSDN') 六、re 正则模块import re str_ = \"sjdcfhksjhfrieuhkjdxn\" r = re.findall(\"abc\") # 字符组 \"[a-zA-Z0-9_]\" # 元字符 # .匹配任意字符 # \\s 匹配任意空白符 # \\w 匹配字母、数字、下划线 # \\d 匹配数字 # \\n 匹配一个换行符 # \\t 匹配一个制表符 # \\b 匹配一个单词结尾 # ^ 匹配一个字符串的开始 # &amp; 匹配一个字符串的结束 # \\ 转义字符 # 量词 # * 出现零次或任意多次 # + 出现一次或任意多次 # ? 出现零次或一次 # {n} 出现n次 # {n,} 出现n或任意多次 # (n,m) 出现n到m次 # 反义词 # \\W 匹配非字母、非数字、非下滑线 # \\D 匹配非数字 # \\S 匹配非空白符 # a|b 匹配字符a或字符b # () 匹配括号内的表达式 # [...] 匹配字符组中的字符 # [^zzn] 匹配除了zzn以外的任意字符 # 匹配手机号 (13|14|15|17|18|[0-9]{9} # 匹配身份证号 \\d{17}[\\d|x]|\\d{15}","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://yanjiuzhe.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"python","slug":"python","permalink":"https://yanjiuzhe.github.io/tags/python/"},{"name":"编程语言","slug":"编程语言","permalink":"https://yanjiuzhe.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"}],"author":"书生"},{"title":"pyMySQL","slug":"pyMySQL","date":"2021-08-19T07:57:13.000Z","updated":"2021-08-19T08:46:42.891Z","comments":true,"path":"posts/594dd1f5.html","link":"","permalink":"https://yanjiuzhe.github.io/posts/594dd1f5.html","excerpt":"","text":"pyMySQL第一章、创建数据库和表1、连接数据库 conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='zzn218', db='zzn', charset='utf8') # 输出&lt;pymysql.connections.Connection object at 0x000002A23020EFD0&gt;，说明连接成功。 参数 host 主机名 port 端口 user 用户名 passwd 密码 charset 编码 2、创建游标，插入数据。要创建游标，通过游标对象就可对数据库进行增、删、查、改。 cur = conn.cursor() 3、创建数据库 cur.execute(\"create database zzn character set utf8;\") 参数： 1）创建数据库，指定数据库名 create database zzn 2）指定编码 character set utf8 4、使用数据库 cur.execute(\"use zzn;\") 5、创建表 cur.execute(\"create table blogs(id char(20), name char(20),) character set utf8;\") 参数 1）创建表 create table 表名(字段名 字段类型，字段名 字段类型) create table 表名(id char(20), name char(20),) 2）指定编码 character set utf8 第二章、增加数据1、导入pymysql库 import pymysql 2、创建数据库连接 conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='zzn218', db='zzn', charset='utf8') print(conn) # 输出&lt;pymysql.connections.Connection object at 0x000002A23020EFD0&gt;，说明连接成功。 参数 host 主机名 port 端口 user 用户名 passwd 密码 db 数据库名 charset 编码 3、创建游标，插入数据，要创建游标,通过游标对象就可对数据库进行增、删、查、改 cur = conn.cursor() 4、sql语句：对数据库进行增、删、查、改 插入 sql = \"insert into stu(name, id) values ('张三','20209020201')\" 4、执行sql语句 cur.execute(sql) 5、向数据库中提交数据 conn.commit() 6、关闭数据库连接（释放资源） conn.close() 第三章、删除数据1、导入pymysql库 import pymysql 2、创建数据库连接 conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='zzn218', db='zzn', charset='utf8')print(conn) 3、创建游标，插入数据，要创建游标,通过游标对象就可对数据库进行增、删、查、改 cur = conn.cursor() 4、sql语句：对数据库进行增、删、查、改 删除 sql = \"delete from zzn where id=202091\" 5、执行sql语句 cur.execute(sql) 6、向数据库中提交数据 conn.commit() 7、关闭数据库连接（释放资源） conn.close() 第四章、修改数据1、导入pymysql库 import pymysql 2、创建数据库连接 conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='zzn218', db='zzn', charset='utf8') 3、创建游标，插入数据，要创建游标,通过游标对象就可对数据库进行增、删、查、改 cur = conn.cursor() 4、sql语句：对数据库进行增、删、查、改 修改 sql = \"update zzn set name=\"'张三'\" where id=20201\" 5、执行sql语句 cur.execute(sql) 6、向数据库中提交数据 conn.commit() 7、关闭数据库连接（释放资源） conn.close() 第五章、查询数据1、导入pymysql库 import pymysql 1、创建数据库连接 conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='zzn218', db='zzn', charset='utf8') 2、创建游标，插入数据，要创建游标,通过游标对象就可对数据库进行增、删、查、改 cur = conn.cursor() 3、sql语句：对数据库进行增、删、查、改 查询语句 # sql = 'select * from stu;' sql = \"select * from stu where id='1'; 4、执行sql语句 cur.execute(sql) 5、查询显示所有的记录 data = cur.fetchall() print(data) 6、关闭数据库连接（释放资源） conn.close() 第六章、例子导入pymysql库 import pymysql # 1、创建数据库连接 conn = pymysql.connect(host='127.0.0.1', port=3306, user='root', passwd='zzn218', db='zzn', charset='utf8') # 2、创建游标，插入数据，要创建游标,通过游标对象就可对数据库进行增、删、查、改 cur = conn.cursor() # 3、sql语句：对数据库进行增、删、查、改 # 增加数据函数 def add_data(): sql = input(\"请输入sql语句：\") # sql = \"insert into stu(name, id) values ('张三','20209020201')\" # 4、执行sql语句 cur.execute(sql) # 5、向数据库中提交数据 conn.commit() # 查询记录，根据id查询信息 def find_data(): id = input(\"请输入查询id：\") # 查询语句 sql = \"select * from stu where id='\"+id+\"'\" # 4、执行sql语句 cur.execute(sql) # 5、查询显示所有的记录 data = cur.fetchall() if(len(data)&gt;0): print(data) else: print(\"无！\") # 修改记录 def revise_data(): id = input(\"修改记录的id\") information = input(\"修改的信息\") now_information = input(\"新信息\") sql = f\"update zzn set {information}={now_information} where id={id}\" cur.execute(sql) conn.commit() # 删除记录 def delete_data(): id = input(\"请输入id：\") sql = f\"delete from zzn where id={id}\" cur.execute(sql) conn.commit() # 6、关闭数据库连接（释放资源） def closs_db(): conn.close() def service(): print(\"欢迎使用数据库管理系统 1.增加记录 2.查询记录 3.修改记录 4.删除记录 0.退出系统\") while True: order = input(\"请输入服务序号：\") if order == \"1\": add_data() closs_db() elif order == \"2\": find_data() closs_db() elif order == \"3\": revise_data() closs_db() elif order == \"4\": delete_data() closs_db() elif order == \"0\": exit() else: print(\"输入错误\") 调用service()函数 service()","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://yanjiuzhe.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://yanjiuzhe.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"pyMySQL","slug":"pyMySQL","permalink":"https://yanjiuzhe.github.io/tags/pyMySQL/"}],"author":"书生"},{"title":"JAVA程序设计","slug":"JAVA程序设计","date":"2021-08-19T07:56:58.000Z","updated":"2021-08-19T08:33:09.159Z","comments":true,"path":"posts/2432baef.html","link":"","permalink":"https://yanjiuzhe.github.io/posts/2432baef.html","excerpt":"","text":"序：java环境的配置 类是对象集合，对象是现实事物的映射对象的特点是属性（变量）对象的行为是方法（函数） 第一章、java基础知识一、Java主类结构public class Hello { public static void main(String[] args){ System.out.println(\"Hello Java\"); } } 第一行，创建一个hello的类，其访问权限为public，public：权限修饰符，允许访问所有的类和包 第二行，创建一个主方法，public：权限修饰符，static：静态修饰符，修饰成员方法和成员变量。void：返回值修饰符，main()：主方法，String[] args：是一个字符串类型的数组，主方法里的参数。 第三行，输出Hello Java，输出方法：System.out.println(\"\"); 二、数据类型1、数值类型： 整数类型：bety(字节型)、short(短整型)、int(整型)、long(长整型) 浮点类型：float(单精度浮点型)、double(双精度浮点型) 2、字符型：char 3、布尔型：ture(真)，flase(假) 4、字符串型：String 5、类：class 6、数组： 7、接口：interface 8、枚举：enum —————————————————————————————————————————————————— 三、标识符与关键字1、转义字符：\\n(换行) 2、标识符标识符就是一个名字，可以用来标识类名、变量名、方法名、数组名、文件名标识符的定义规则：只能由字母、数字、下划线_、美元符号$组成，且数字不能在首位。字母区分大小写。关键字不能做标识符。 3、关键字 import 表明要访问指定的类或包 package 包 class 类 public 一种访问控制方式：共用模式 private 一种访问控制方式：私用模式 protected 一种访问控制方式：保护模式 static 表明具有静态属性 void 声明当前成员方法没有返回值 new 用来创建新实例对象 byte 基本数据类型之一，字节类型 short 基本数据类型之一,短整数类型 int 基本数据类型之一，整数类型 long 基本数据类型之一，长整数类型 float 基本数据类型之一，单精度浮点数类型 double 基本数据类型之一，双精度浮点数类型 char 基本数据类型之一，字符类型 boolean 基本数据类型之一，布尔类型 null 零 true 真 false 假 final 用来定义常量和说明最终属性，表明一个类不能派生出子类，或者成员方法不能被覆盖，或者成员域的值不能被改变 const 保留关键字，没有具体含义 if 条件语句的引导词 else 用在条件语句中，表明当条件不成立时的分支 switch 分支语句结构的引导词 case 用在switch语句之中，表示其中的一个分支 default 默认，例如，用在switch语句中，表明一个默认的分支 do 用在do-while循环结构中 while 用在循环结构中 for 一种循环结构的引导词 break 提前跳出一个块 continue 回到一个块的开始处 goto 保留关键字，没有具体含义 return 从成员方法中返回数据 abstract 表明类或者成员方法具有抽象属性 extends 表明一个类型是另一个类型的子类型，这里常见的类型有类和接口 implements 表明一个类实现了给定的接口 interface 接口 native 用来声明一个方法是由与计算机相关的语言（如C/C++/FORTRAN语言）实现的 strictfp 用来声明FP_strict（单精度或双精度浮点数）表达式遵循IEEE 754算术规范 synchronized 表明一段代码需要同步执行 transient 声明不用序列化的成员域 volatile 表明两个或者多个变量必须同步地发生变化 instanceof 用来测试一个对象是否是指定类型的实例对象 super 表明当前对象的父类型的引用或者父类型的构造方法 this 指向当前实例对象的引用 try 尝试一个可能抛出异常的程序块 catch 用在异常处理中，用来捕捉异常 throw 抛出一个异常 throws 声明在当前定义的成员方法中所有需要抛出的异常 ———————————————————————————————————————————————— 四、常量与变量1、变量变量名是是标识符，每次声明变量编译器会根据数据类型给变量分配内存。 变量的声明与初始化，就是定义并第一次给变量赋值语法： 数据类型 变量名 = 值; 例：float a = 10f; # 浮点型数据赋值，一般值后面要带f或d。 2、常量：不能被改变量，常量名一般大写 常量的声明与初始化语法： final 数据类型 常量名 = 值; 例：final double PI = 3.1415926; 3、变量的作用域变量的作用域是指变量的生存周期，出了该区域变量将不存在。 (1)、成员变量成员变量在整个类中有效，成员变量分为静态变量和实例变量例: class var{ int x = 10; static int y = 20; } # x是实例变量，y是类变量(静态变量)，静态变量的有效范围可以跨类，在其他类里可以通过\"类名.静态变量\"调用。 (2)、局部变量定义在{}块里的变量，只在块里有效。 当成员变量与局部变量重名，则成员变量将被隐藏。———————————————————————————————————————————————— 五、运算符自增自减运算符：++ – 算术运算符：+ - * / % 关系运算符：== != &gt; &gt;= &lt; &lt;= 逻辑运算符：&amp;&amp; || ! 位运算符：&amp; | ~ ^ &gt;&gt; &lt;&lt; &gt;&gt;&gt; 赋值运算符：= += -= *= /= %= 条件运算符：？： 逗号运算符：， ()：定义函数时容纳参数，在控制语句或强制类型转换的表达式中表示执行或计算的优先权。 []：用来进行数组声明 {}：定义块、类、方法及局部范围，也可以用来初始化数组的值。———————————————————————————————————————————————— 六、数据类型转换1、隐式类型转换低级类型会自动向高级类型转换bety &gt; short &gt;int &gt;long &gt;float &gt; double 2、强制类型转换高级类型向低级类型转换，会出现数据丢失。语法：(数据类型)值;———————————————————————————————————————— 七、编码规范1、代码注释单行注释：//多行注释：/* */文本注释：/** */ 2、每条语句要独占一行，一条语句结束要以分号结尾。 3、区分大小写，符号是英文的，类名首字母大写，方法名首字母写，其余大写。 4、代码中的空格与换行，对运行没有影响。 第二章、流程控制一、选择结构语句1、if语句使用if语句，当if的条件成立，则执行其后语句；不成立，则不执行。条件一定是布尔表达式，表达式的结果一定是true或false。 语法： if(条件){ 语句； } 例子： int a=10,b=20; if(a&lt;b){ System.out.println(\"Hello Java\"); } 结果：Hello Java 2、if-else语句使用if-else语句，当if的条件成立，则执行其后语句；不成立，则执行else的语句。条件一定是布尔表达式，表达式的结果一定是true或false 语法： if(条件){ 语句1; }else{ 语句2; } 例子; int a=10,b=20; if(a&lt;b){ System.out.println(\"a&lt;b\"); }else{ System.out.println(\"a&gt;b\"); } 结果：a&lt;b 3、if-else if-else语句使用if-else if-else语句，当if的条件成立，则执行其后语句；不成立，则在判断else if的条件，成立就执行语句，不成立就执行else的语句。条件一定是布尔表达式，表达式的结果一定是true或false 语法： if(条件){ 语句1; }else if{ 语句2; }else{ 语句3; } 例子; int a=10; if(a==0){ System.out.println(\"a是零\"); }else if(a&gt;0){ System.out.println(\"a大于零\"); }else{ System.out.println(\"a小于零\"); } 结果：a大于零 4、条件运算符：？：当条件为真把语句1赋给变量，条件为假把语句2赋给变量。 语法： 变量 = 条件？语句1：语句2； 例子 int a, b=10, c=20; a = 10&lt;20?b:c; 结果：a等于10 5、switch-case-default多分支语句switch语句中的表达式的值必须为整数型、字符型、字符串型。switch语句会判断表达式的值是否与case后面的值相同，相同则执行case后面的语句，直到遇到break或花括号}，全部不相同则执行default语句。 语法： switch(表达式){ case 1: {语句1; } break; case 2: {语句2; } break; case 3: {语句3; } break; case 4: {语句4; } break; case 5: {语句5; } break; default: {语句; } } 例子： int a=1; switch (a){ case 1: {System.out.println(\"A\");} break; case 2: {System.out.println(\"B\");} break; case 3: {System.out.println(\"C\");} break; case 4: {System.out.println(\"E\");} break; case 5: {System.out.println(\"F\");} break; default: {System.out.println(\"输入错误\");} } 结果：A 二、循环结构语句1、while循环语句使用while语句，当条件成立，语句开始循环，直到条件不成立，结束语句循环。 语法： while(条件表达式){ 语句; } 例子： int a=0; while (a&lt;10){ System.out.println(a); a++; } 结果：0，1，2，3，4，5，6，7，8，9 2、do-while语句使用do-while语句，会先执行一遍语句，在判断条件是否成立，成立，则继续执行，不成立，则结束循环。 语法： do{ 语句; }while(条件表达式); 例子; int a=0; do{ System.out.println(a); a++; }while(a&lt;10); 结果： 0 1 2 3 4 5 6 7 8 9 3、for语句使用for语句，当循环条件成立，语句开始循环，直到条件不成立，结束语句循环。表达式1是负责变量的初始化，表达式2是循环条件，表达式3是循环控制条件。 语法： for(表达式1；表达式2；表达式3){ 语句； } 例子： int a; for(a=0;a&lt;10;a++){ System.out.println(a); } 结果：0 1 2 3 4 5 6 7 8 9 4、for-each语句主要用来遍历数组 语法： for(元素变量：遍历对象){ 引用元素变量的语句; } 例子： 定义一个数组，在for语句里定义一个元素变量和放入一个数组，然后就遍历输入数组里的元素。 int rank[] = {0,1,2,3,4,5,6,7,8,9}; for(int a: rank){ System.out.println(a); } 结果：0，1，2，3，4，5，6，7，8，9 5、跳转语句（1）break：跳出当前循环体。 int a=0; while (a&lt;10){ System.out.println(a); if (a==5) {break;} a++; } 结果：0 1 2 3 4 5 （2）continue：跳过当前循环 int a=0; while (a&lt;10){ a++; if (a==5) continue; System.out.println(a); } 结果：0 1 2 3 4 6 7 8 9 第二章、数组一、一维数组1、数组的静态定义，定义一个长度为5的整型数组，并初始化 1）创建数组并初始化 int[] number = {1,2,3,4,5,}; 2）数组访问，根据下标引用数组：数组名[3]; number[0]; 3）输出数组的元素 for (int x:number) { System.out.println(x); } 2、数组的动态定义，定义一个长度为5的整型数组 声明一个长度为5的整型数组 int[] number2 = new int[5]; 给数组元素赋值 number2[0] = 10; number2[1] = 20; number2[2] = 30; number2[3] = 40; number2[4] = 50; 引用数组 number2[0]; 输出数组的元素 for (int x:number2){ System.out.println(x); } 3、其他类型的数组的定义 String[] number3 = new String[5]; float[] number4 = new float[5]; double[] number5 = new double[5]; char[] number6 = new char[5]; 4、查看数组的长度 length 查看数组长度：number2.length System.out.println(\"number2数组的长度是：\" + number2.length); 二、二维数组1、静态二维数组的定义和初始化 int[][] number = {{1,2,3}, {4,5,6}, {7,8,9}}; 访问数组 number[0][0]; 输出二维数组 for (int i=0;i&lt;3;i++){ for (int j=0; j&lt;3; j++){ System.out.println(number[i][j]); } } 2、动态二维数组的定义 int[][] number1 = new int[3][3]; 动态二维数组的赋值 number1[0][0] = 10; number1[0][1] = 20; number1[0][2] = 30; number1[1][0] = 40; number1[1][1] = 50; number1[1][2] = 60; number1[2][0] = 70; number1[2][1] = 80; number1[2][2] = 90; 访问数组 number1[0][0]; 输出二维数组 for (int i=0;i&lt;3;i++){ for (int j=0; j&lt;3; j++){ System.out.println(number1[i][j]); } } 三、数组排序 1、第一种排序算法：选择排序 int[] number1 = {1,10,2,9,3,8,4,7,5,6}; for (int j=0;j&lt;number1.length-1;j++){ int min = j; for (int i=j+1; i&lt;number1.length;i++){ if (number1[i] &lt; number1[min]){ min = i; } } int temp = number1[j]; number1[j] = number1[min]; number1[min] = temp; } 输出数组 for(int x: number1){ System.out.println(x); } 2、第二种排序算法：冒泡排序 int[] number2 = {1,10,2,9,3,8,4,7,5,6}; int t; for(int i=0; i&lt;number2.length; i++){ for (int j=i+1; j&lt;number2.length; j++){ if(number2[i] &gt; number2[j]){ t = number2[i]; number2[i] = number2[j]; number2[j] = t; } } } 输出 for(int x: number2){ System.out.println(x); } 3、第三种排序算法：插入排序 int[] number3 = {1,10,2,9,3,8,4,7,5,6}; for (int i=1; i&lt;number3.length; i++){ int temp = number3[i]; for (int j=i-1; j&gt;=0; j--){ if (number3[j]&gt;temp){ number3[j+1] = number3[j]; if(j==0){number3[0]=temp;} }else{ number3[j+1] = temp; break; } } } 输出 for(int x: number3){ System.out.println(x); } 四、对象数组1、创建静态对象数组，并初始化 要先创建BankAccount对象 // 静态初始化对象数组 BankAccount对象[] accounts = { new BankAccount(\"张三\",21), new BankAccount(\"李四\",22), new BankAccount(\"王五\",20), new BankAccount(\"马六\",19), new BankAccount(\"孙七\",18), }; 2、创建动态对象数组，并初始化 要先创建BankAccount对象 // 动态创建数组 BankAccount[] accounts1 = new BankAccount[5]; // 初始化数组 accounts1[0] = new BankAccount(\"张三\",21); accounts1[1] = new BankAccount(\"张三\",21); accounts1[2] = new BankAccount(\"张三\",21); accounts1[3] = new BankAccount(\"张三\",21); accounts1[4] = new BankAccount(\"张三\",21);} 第三章、字符串String：字符串是由双引号包裹的一连串字符 一、String类1、字符串变量的定义和初始化 String a = new String(\"hello\"); String a = \"hello\"; 2、创建字符串对象 第1种、直接创建 String 字符串名 = \"字符串\"; String str = \"Hello world!\"; 第2种、使用new创建 (1)、String(String original)用一个字符串创建一个String对象 实例： String s = new String(\"Hello world!\"); (2)、String(char a[], int offset, int length)提取字符数组a中的一部分创建一个字符串对象。参数offset表示开始截取字符串的位置。lengh表示截取字符串的长度。 实例： char a[] = {'h', 'e' ,'l','l', 'o' }; String s = new String(a, 1, 5); (3)、String(char[] value)该构造方法可分配一个新的String对象，使其表示的字符串数组参数中所有元素连接的结果。 char a[] = {'h', 'e', 'l', 'l','o'}; String s = new String(a); 二、字符串操作方法1、获取字符串的长度：length() str.length(); 2、字符串查找：indexOf(String s)、lastIndexOf(String s) :返回搜索的字符或字符串首次出现的下标，如果没有该字符串则返回-1，str:字符串对象、s是指定的搜索字符串 str.indexOf(String s); :返回搜索的字符或字符串最后出现的下标，如果没有该字符串则返回-1，str:字符串对象、s:要搜索的字符串 str.lastIndexOf(String s); 3、获取指定下标位置的字符：charAt(int a) :返回下标处的字符，str:任意字符串对象，a:字符下标 str.charAt(int a); 4、字符串切片：substring(0,3) :截取下标3-结尾的子串，str:任意字符串对象，3:字符串下标 str.substring(3); :截取下标0-3的子串，str:任意字符串对象，0,3:字符串下标 str.substring(0,3); 5、去除字符串里的空格：trim() :去除字符串头和尾的空格 str.trim(); 6、字符串替换：replace(oldChar, newChar) 替换指定字符串 str.replace(oldChar, newChar) 替换全部字符串 str.replaceAll(oldChar, newChar) 替换首个字符串 str.replaceFirst(oldChar, newChar) 7、判断字符串的开始和结尾 1）判断当前字符串对象的前缀是否为指定的字符串，返回Boolean，str:任意字符串对象，s:指定字符串 str.startsWith(String s) 2）判断当前字符串对象的后缀是否为指定的字符串，返回Boolean，str:任意字符串对象，s:指定字符串 str.endsWith(String s) 8、判断字符串是否相等 区分大小写，判断两个字符串的长度和字符,str:任意字符串对象，s:是指定字符串 str.equals(String str); 忽略区分大小写，判断两个字符串的长度和字符,str:任意字符串对象，s:是指定字符串 str.equalsIgnoreCare(String str); 比较运算符==：比较地址是否相同 9、按字典顺序比较两个字符串 如果字符串对象在参数之前，则返回一个负整数；如果字符串对象在参数之后，则返回一个负整数；如果字符串对象与参数相等，则返回一个0 str.compareTo(String s); 按字典顺序比较两个字符串，但忽略大小写。 str.compareTolgnoreCase(String s); 10、字符串的大小写转换 str.toLouerCase() 全部小写 str.toUpperCase() 全部大写 11、字符串分割1）以指定的分割符进行分割，分割符可以是字符串，也可以是正则表达式 （使用|定义多个分割符 a|b 分割符是a和b） str.split(Sing s) 2）指定的分割符和分割次数进行分割，分割符可以是字符串，也可以是正则表达式 str.split(String s, int 5) 三、字符串基本操作1、连接字符串 运用连接“+”符号，能将其他数据类型转换成String类型，并相连。 inrt a = 10; System.out.println(\"hello\" + \"java\" + a); 2、去除字符串的空格 去除两端空格 str.trim(); 去吃全部空格 str.replace(\" \", \"\"); 3、格式化字符串format() 1）语法：String=字符串, format=字符串格式 str.format(String, format); 2）转换符： %n 换行符 %s 字符串类型 %c 字符类型 %d 整数类型 %f 浮点类型 %b 布尔类型 3）例子： String str = \"world\"; str.format(\"你好，%s!\", str); 4、字符串生成器（String-Builder） append(content) 添加内容， insert(int a, data) 向指定a的位置插入数据 delete(int a, int b) 删除下标a到下标b的字符 5、正则表达式 import java.util.regex.*; # 字符组 \"[a-zA-Z0-9_]\" # 元字符 .匹配任意字符 \\s 匹配任意空白符 \\w 匹配字母、数字、下划线 \\d 匹配数字 \\n 匹配一个换行符 \\t 匹配一个制表符 \\b 匹配一个单词结尾 ^ 匹配一个字符串的开始 &amp; 匹配一个字符串的结束 \\ 转义字符 # 量词 * 出现零次或任意多次 + 出现一次或任意多次 ? 出现零次或一次 {n} 出现n次 {n,} 出现n或任意多次 (n,m) 出现n到m次 # 反义词 \\W 匹配非字母、非数字、非下滑线 \\D 匹配非数字 \\S 匹配非空白符 a|b 匹配字符a或字符b () 匹配括号内的表达式 [...] 匹配字符组中的字符 [^zzn] 匹配除了zzn以外的任意字符 例子1：匹配手机号 (13|14|15|17|18|[0-9]{9} 例子2：匹配身份证号 \\d{17}[\\d|x]|\\d{15} 四、StringBuilder类StringBuilder是一个可变的字符序列，StringBuilder类的值除字符序列外，还有预留空间，可以直接在字符序列上进行追加、插入、删除操作，因此被称为缓冲型字符串类。方法与StringBuffer一样，速度比StringBuffer快，当单线程操作字符串缓存区时，使用StringBuilder。 1、创建StringBuilder类 （1）StringBuilder() 创建一个空的字符串缓存区，初始容量为16 StringBuilder a = new StringBuilder(); （2）StringBuilder(int a) 创建一个空的字符串缓存区，指定初始长度 StringBuilder a = new StringBuilder(100); （3）StringBuilder(String str) 创建一个字符串缓存区，并初始化内容，初始化长度是字符串长度+16 StringBuilder a = new StringBuilder(); 2、StringBulider的方法 length()、charAt()、indexOf()、lastindexOf()、subtring()、 1）追加字符串：append() 该方法可以将数据转换成字符串，并添加到字符串缓存区。 StringBuilder str = new StringBuilder(\"Hello,\"); str.append(\"world\"); 2）插入字符串：insert() 该方法可以将数据转换成字符串，并插入到指定的字符串缓存区。 StringBuilder str = new StringBuilder(\"Hello,\"); str.insert(6, \"world\"); 3）删除字符串：delete()、deleteCharAt() delete() 删除指定开始和结束位置上的字符串 deleteCharAt() 删除指定位置上的字符串 StringBuilder str = new StringBuilder(\"Hello,world!\"); str.delete(6, 11); str3.deleteCharAt(1); 4）反转字符串：reverse() 将字符串的内容倒序输出 StringBuilder str4 = new StringBuilder(\"Hello,world!\"); str4.reverse(); System.out.println(str4); 5）替换字符串：replace()、setCharAt replace() 径指定位置字符串替换成新字符串 setCharAt() 将字符串中指定位置的字符替换成新字符 StringBuilder str5 = new StringBuilder(\"Hello,world!\"); str5.replace(6,11, \"Java\"); str5.setCharAt(0, 'h'); 五、StringBuffer类StringBuffer是一个可变的字符序列，StringBuilder类的值除字符序列外，还有预留空间，可以直接在字符序列上进行追加、插入、删除操作，因此被称为缓冲型字符串类。功能和方法与StringBuilder一样。当多线程操作字符串缓存区时，使用StringBuffer。 第四章、面向对象第一节、类和对象一、面向对象类是对象的集合，对象是现实事物的映射，用对象之间的关系来描述事物之间的联系。 面向对象就是将解决的问题划分成多个独立的对象，通过调用对象的方法来解决问题。 面向对象的特性：封装性、继承性、多态性。 二、类和对象在面向对象中具有相同属性和相同方法的一组对象就是类，对象是类的实例化。类具有属性和方法，类是一种抽象的数据类型。 1、使用关键字class定义类 public class DefineClass { 1）定义类的属性（类的变量） String name; int age; 2）类的构造方法 DefineClass(){} DefineClass(String name, int age){ this.name=name; this.age=age; } 3）定义类的方法（类的函数） void print(){ System.out.print(\"名字\"+name + \"年龄\"+age); } // main方法：程序的开始点 public static void main(String[] args) { 4）实例化一个类 DefineClass persoan = new DefineClass(); 5）使用类，调用属性 persoan.name = \"唐三\"; 6）使用类，调用方法 persoan.print(\"张三\", 21); } } 2、属性和方法 1）属性： 定义属性 class car{ String name; String sex; int age; } 2）方法： 语法格式： 修饰符 返回类型 方法名(参数列表){ 方法体; 返回值; } 修识符： 定义方法的访问权限 返回类型 方法返回的数据类型，没有返回值，则是void 方法名： 标识符 参数列表： 方法体： 定义方法 class car{ 方法1 void sleep(){ System.out.println(\"睡觉\"); } 方法2 void info(){ System.out.println(\"姓名：\"+name+\"，性别：\"+sex+\"年龄\"+age); } } 三、构造方法1、构造方法（就是对象的初始化），使用new调用构造方法创建对象。 1）构造方法是一种特殊的方法，在实例化类时，完成类的属性初始化，并且可以设置默认值，限定实例化。2）构造方法没有返回值，不能写void，3）构造方法的名字必须和类名一样。每个类至少有一个构造方法。4）构造方法只能由new运算符调用，用户不能直接调用构造方法，5）没有写构造方法，系统会自动定义默认构造 2、默认构造方法 类名(){} 3、构造方法的语法 语法格式： [权限修饰符] 类名(参数){ 构造体; } 例如： public cat(String name, int age) { this.name = name; this.age = age; } 4、调用构造方法（就是类的实例化，就是创建对象） cat c1 = new cat(\"黑猫警长\", 17); 四、对象1、声明对象 类名 对象名; person p1; 2、实例化对象 对象名 = new 类名(); p1 = new person(); 3、创建对象 类名 对象名 = new 类名(参数列表); person p1 = new person(); 4、使用对象 1）引用对象属性 对象名.成员变量名 p1.name; 2）调用对象方法 对象名.方法名([参数列表]); p1.print(); 五、对象值的传递1、值传递 prblic class Test{ 定义普通方法：设置两个参数，无返回值。 public sattic void haha(int a, int b){ int sum = a + b; System.out.println(sum); } main方法：将值传递到haha方法中。 public static void main(String[] args){ haha(3, 5); } } 2、引用传递 引用传递也叫值传递，方法调用传递是参数的地址。 传递对象 创建类，定义属性 calss A { int i = 0; } 创建测试类 public class Test{ 对象.属性，将A类的i属性进行++。 public static void add(A a){ // a = new A(); a.i++; } main方法：将a对象传递到add方法 public static void main(String[] args){ A a = new A(); add(a); System.out.print(a.i); } } 当a = new A();行注释掉，输出的是1，没有注释掉是0。原因是当a = new A();行存在时创建了新的a对象，将原本的传递进来的a对象覆盖掉了。 六、访问权限修饰符1、private：私用模式（当前类） 只能被所属的类访问，外界访问私有的需要使用get()和set方法，get()获取值，set()赋予值。 2、默认访问修饰符：（当前类、当前的包） 只能是同一个包中进行访问， 3、protected：保护模式（当前类、子孙类、当前包） 能被包中的子类访问，不能修饰类、接口，只能修饰属性和方法。 4、public：共用模式（当前类、子孙类、当前包、其他包） 能被所有的类访问 七、非访问权限修饰符1、static修饰符 static修饰符用来修饰成员变量和成员方法，static修饰的成员变量和成员方法，叫静态变量和静态方法，可直接通过类名访问。 1）静态变量，静态变量全部大写，静态变量可以通过类名.属性名调用，所有的类共享静态变量。静态变量一般保存公共的变量。 定义静态变量： private static String name; 2）静态方法，构造函数不能定义为静态变量，静态方法一般用于提供公共的方法。 定义静态方法： static void print(){ } 3）静态代码块， 定义静态代码块： static{ } 2、final修饰符 1）修饰类 当用final修饰一个类时，表明这个类不能被继承。 2）修饰方法 使用final修饰方法，是把方法锁定，以防任何继承类修改它的含义 3）修饰变量 用final修饰的成员变量叫常量，基本数据类型的常量，赋值后无法改变；如果是引用类型的常量，则在对其初始化之后便不能再让其指向另一个对象。 4） final变量一旦被初始化赋值之后，就不能再被赋值了 被final修饰的引用变量一旦初始化赋值之后就不能再指向其他的对象， 但引用变量指向的对象内容是可变。 static和final关键字混淆，static作用于成员变量用来表示只保存一份副本，而final的作用是用来保证变量不可变。 3、abstract修饰符 abstract用来修饰类，这个类叫抽象类。 4、synchronized修饰符 synchronized修饰的方法，在同一时间只能被一个线程访问。 5、transient修饰符 transient用来预处理类和变量。当对象中包含transient修饰的成员变量时，ＪＶＭ会跳过该特定的变量。 ６、volatile修饰符 当一个变量被volatile修饰时，那么对它的修改会立刻刷新到主存，当其它线程需要使用该变量时，会去内存中读取新值。当线程在释放锁之前，会把共享变量值都刷回主存。 八、类的加载内存图类的加载过程 hello.java &gt; javac编译&gt;&gt; hello.class &gt; 加载内存（load、Link、Init：加载，链接，初始化）&gt;&gt; 内存运行class 类的描述，也叫元数据（描述数据的数据） 反编译cmd: javap 加了static就存储在元数据区（方法区） 基础类型：存储在栈里 引用类型：存储在堆里 方法： 元数据（方法区） 1）基础数据类型：字节类型、短整数类型、整数类型、长整数类型、单精度浮点类型、双精度浮点类型、字符类型、布尔类型、 2）引用数据类型：数组类型、字符串类型，类类型 九、包的定义和导入包：就是一个文件夹: package １、包的声明：顶级域名.jd.项目名.模块名.类名 ：com.jd.pro1.m1.class ２、包的导入 import 包名.类名 import 包.* ３、常见的包名： java.String ：字符串的包 java.lang ：语言包，包含基本的类和接口 java.util ：包含实用工具类和接口 java.awt ：抽象窗口工具包，包含创建和维护图形窗口的所有的类和接口 java.swing ：在awt基础上提供的界面工具包 java.applet ：包含输入和输出的类 java.sql ：包含数据库的sql语句 第二节、封装性一、类的封装1、将属性和方法设置成私有，在使用getter()和setter()方法区访问 二、setter和getter方法1、当一个类的成员变被定义成了private其他的类就不能访问，为private成员变量提供一个公共的访问方法、外界就可以通过共有的方法来间接访问它。 2、在setter方法和getter方法里对变量进行验证，对不符合要求的禁止修改。 3、getter()方法： getter方法：读取对象的属性值，并返回。 语法： public AttributeType getAttributeName(){} 参数 AttributeType：方法的返回类型，类型与读取成员变量的类型一致。 getAttributeName，读取成员变量的名字，首字母大写，方法没有参数。 4、setter方法： setter方法：设置对象的属性值，可以增加一些检查措施 语法： public void setAttributeName(AttributeType parameterName){} 参数 parameterName设置成员变量的名字，首字母大写 方法参数类型与要设置的成员变量的类型一致，方法没有返回值。 第三节、继承性一、继承继承在已有的类上派生出新类，子类继承父类的属性和方法，子类自己也有属性和方法。 语法格式: class 子类名 extends 父类名 { 语句体; } 实例： 定义父类 class Animal{ 定义属性 public String name; private int id; 定义方法 public void eat(){ System.out.println(name+\"正在吃\"); } public void sleep(){ System.out.println(name+\"正在睡\"); } } 定义子类，并继承父类 class Cat extends Animal { public void shout(){ System.out.println(name+\"正在叫\"); } } 父类有一个共有属性，一个私有属性和两个共有方法，子类虽然只有一个方法，但子类继承了父类，具有父类的一个共有属性和两个私有方法，父类的私有属性不能被子类继承。 1、子类继承父类的成员变量 子类继承父类只能的public和protected成员变量，不能继承父类的private成员变量。 当子类和父类在同包下才能继承protected成员变量。 子类继承父类的成员变量，但子类有父类中的同名变量，父类中的同名变量会隐藏。子类需要使用super关键字来进行引用。 2、子类继承父类的方法 子类继承父类只能的public和protected成员方法，不能继承父类的private成员方法。 当子类和父类在同包下才能继承protected成员方法。 子类继承父类的成员方法，但子类有父类中的同名方法，父类中的同名方法会覆盖。子类需要使用super关键字来进行引用。 3、构造方法 子类不能继承父类的构造方法。如果父类的构造方法有参数，子类需要使用super关键字进行调用。若父类的构造方法没有参数，则不需要使用super关键字。如果没有使用super关键字，则系统会自动调用父类的默认构造方法。 二、super关键字super关键字能访问隐藏的父类的成员变量和成员方法。 1、访问被隐藏的同名成员变量 super.成员变量 2、访问被覆盖的同名成员方法 super.成员方法([参数列表]) 3、访问父类的构造方法 要在子类构造方法中继承父类构造方法 public Son(){ super([参数列表]); } 三、抽象类和抽象方法1、一个抽象类至少有一个抽象方法，抽象方法是只声明未实现的方法。使用abstract关键字定义抽象类和抽象方法。 语法格式： 抽象类 abstract class 类名 { 抽象类体; } 抽象方法 abstrace 返回类型 方法名(参数列表); 2、实例： 1、定义抽象类 abstract class Employee { 定义抽象方法 public abstract void work(); } 2、定义普通类继承抽象类 class Programmer extends Employee{ @Override 实现继承来的抽象方法 public void work(){ System.out.println(\"我是程序员，写了一整天的代码！\"); } } 3、主方法：实例化Programmer类，并调用抽象方法 public class Test { public static void main(String[] args) { Programmer p = new Programmer(); p.work(); } } 四、接口接口是方法定义和常量值的集合，接口中定义的方法都是抽象方法，实现接口的类要实现接口中定义的所有方法。 1、接口的定义： 语法格式： [public] interface 接口名 [extends 父接口列表]{ // 接口体 // 常量域声明 [public] [static] [final]域类型 域名=常量值; // 抽象方法声明 [public] [abstract] 返回值类型 方法名([参数列表]); } 其中： 使用extends继承父接口，可继承多个父接口。 接口中可以有静态的公开常量，用public static final修饰的。 接口中的所有方法都是抽象的和公开的，用public abstract修饰的。 2、接口的实现： 定义了接口，需要有普通类来实现，在类定义中使用inplements关键字来实现接口，一个类可以继承多个接口。 语法格式： class 类名 implements 接口 { 类体; } 其中： 若实现接口的类不是抽象类，则需要实现接口中所有方法。 接口中抽象方法的访问修饰符默认是public，所以实现中必须明确的写出public修饰符。 3、接口的应用 实现接口：通过类对接口的实现，实现接口中的方法。 接口作为参数：接口可作为方法定义时的参数，在实际调用方法时传入接口实现类 4、实例： 1、创建接口类 public interface weChat { void wepay(); } 2、创建接口类 public interface BaiduMap { void map(); } 3、实现接口类 public class Test implements weChat,BaiduMap{ // 实现接口方法 @Override public void map() { System.out.println(\"微信支付\"); } @Override public void wepay() { System.out.println(\"百度地图\"); } // 主方法：创建测试对象 public static void main(String[] args) { Test t = new Test(); t.map(); t.wepay(); } } 第四节、多态多态是指一个方法只有一个名字，但有多种行为，即一个类中存在多个同名方法，使对象具有不同的行为，实现了对象的多态性。 多态可以利用重载实现，也可以通过子类对父类方法的覆盖实现。重载是一种静态的多态，覆盖是一种动态的多态。 一、重载1、同一个类中有多个名字相同的方法，且每个方法的参数不一样，这被称为方法的重载。 1）方法相同 2）方法的参数类型、个数不相同、返回类型不相同、方法的修饰符不相同 3）main方法也可以重载 2、实例： public class 方法的重载 { public static void add(int a, int b){ System.out.println(a+b); } public static void add(int a, int b, int c){ System.out.println(a+b+c); } public static void add(int a, double b){ System.out.println(a+b); } public static void main(String[] rags){ add(1,2); add(1,2,3); add(1,1.2); } } 二、覆盖多态存在的前提：要有继承关系、子类重写父类的方法、父类引用指向子类 覆盖是子类对父类方法的重写，当子类和父类的名字、参数列表、返回类型相同时才能实现覆盖。 1、方法的覆盖 父类 public class Father { public void sayHello(String name){ System.out.println(name+\"在说中文：你好\"); } } 子类 public class Son extends Father{ public void sayHello(String name){ System.out.println(name+\"speak English: Hello!\"); } } 主方法 public class Test { public static void main(String[] args) { Father f = new Father(); Son s = new Son(); f.sayHello(\"张三\"); s.sayHello(\"jk\"); } } 2、引用数据类型转换 引用变量的数据类型转换只是继承层次的 子类可以自动转换成父类对象 父类需要强制类型转换才能转换成子类 1）向上转型：子类对象转换成父类对象 把子类对象赋值给父类引用变量 父类 a = new 子类(); 实例： 父类 public class Father { public void sayHello(String name){ System.out.println(name+\"在说中文：你好\"); } } 子类 public class Son extends Father{ public void sayHello(String name){ System.out.println(name+\"speak English: Hello!\"); } } 主方法 public class Test { public static void main(String[] args) { 将子类对象赋值给父类引用变量 Father a = new Son(); } } 2）向下转型：父类对象可以强制转换成子类对象 把子类对象赋值给父类引用变量 父类 a = new 子类(); 实例： 父类 public class Father { public void sayHello(String name){ System.out.println(name+\"在说中文：你好\"); } } 子类 public class Son extends Father{ public void sayHello(String name){ System.out.println(name+\"speak English: Hello!\"); } } 主方法 public class Test { public static void main(String[] args) { 创建父类对象 Father a = new Father(); 将父类对象强制转换成子类对象，并调用子类对象的方法。 ((Son)a).SayHello(); } } 第五节、泛型泛型：声明类型参数在使用时用具体类型来替换。泛型类、泛型接口、泛型方法。 一、使用Object当做泛型 使用Object类型数据创建对象，但在调用对象，要向下转型会抛出异常。 实例： 定义Salary类： public class Salary { // Object类型的数据 private Object x; private Object y; public void setX(Object x) { this.x = x; } public void setY(Object y) { this.y = y; } public Object getX() { return x; } public Object getY() { return y; } } 定义测试类： public class Test { public static void main(String[] args) { Salary s = new Salary(); s.setX(6000); s.setY(\"四千\"); System.out.println(\"本月工资是：\"+s.getX()); System.out.println(\"本月工资是：\"+s.getY()); } } 二、泛型应用 1、泛型的规则 1）泛型的类型参数只能是类(包括自定义类)，不能是基本数据类型。 2）泛型的类型参数可以有多个，同一个泛型可以对应多个版本，不同版本的泛型类实例时不兼容的。 3）泛型的参数类型可以使用extends语句，被叫作有界类型 例如：&lt;T extends superclass&gt; 4）泛型的参数类型可以是通配符类型 例如：Class&lt;? &gt; classType=Class.forName 2、泛型类 定义泛型类 public class Salary &lt;T1, T2, T3&gt;{ private T1 x; private T2 y; private T3 z; public void setX(T1 x) { this.x = x; } public void setY(T2 y) { this.y = y; } public void setZ(T3 z) { this.z = z; } public T1 getX() { return x; } public T2 getY() { return y; } public T3 getZ() { return z; } } 定义测试类 public class Test { public static void main(String[] args) { Salary&lt;Integer, Double,String&gt; s1 = new Salary&lt;Integer,Double, String&gt;(); s1.setX(6000); s1.setY(6000.00); s1.setZ(\"六千\"); System.out.println(\"本月工资是：\"+s1.getX()); System.out.println(\"本月工资是：\"+s1.getY()); System.out.println(\"本月工资是：\"+s1.getZ()); } } 3、泛型方法 定义泛型类，定义泛型方法 public class Salary&lt;T1, T2&gt;{ private T1 x; private T2 y; public T1 getX() { return x; } public void setX(T1 x) { this.x = x; } public T2 getY() { return y; } public void setY(T2 y) { this.y = y; } /* 定义泛型方法*/ public &lt;T1,T2&gt; void printSalary(T1 x, T2 y){ T1 m = x; T2 n = y; System.out.println(\"基本工资：\"+m+\"，项目提成：\"+n); } } 定义测试类 public class Test { public static void main(String[] args) { Salary&lt;Integer,String&gt; s1 = new Salary&lt;Integer, String&gt;(); s1.setX(6000); s1.setY(\"六万\"); s1.printSalary(s1.getX(), s1.getY()); } } 4、泛型接口 定义泛型接口： public interface OtherSalary &lt;T1&gt;{ T1 getSalary(); } 实现泛型接口 public class Salary&lt;T1&gt; implements OtherSalary&lt;T1&gt;{ private T1 money; // 定义泛型构造方法 public Salary(T1 money){ this.money=money; } @Override public T1 getSalary() { return this.money; } } 定义测试类： public class Test { public static void main(String[] args) { Salary&lt;Integer&gt; s = new Salary&lt;Integer&gt;(3000); System.out.println(\"兼职收入：\"+ s.getSalary()); } } 第五章、Java常用类一、包装类包装类可以将基本数据类型的变量包装成对象 1、包装类的继承关系 Object的子类是：Class、Void、Number、Boolean、Character Number的子类是：Byte、Short、Integer、Long、Float、Double 2、（装箱） 1）将基本数据类型包装成类对象 整型包装类对象 int a = 1; Integer Obj_a = new Ineger(a); 浮点型包装类对象 float b = 1.2f; Float obj_b = new Float(b); double c = 1.2d Double obj_c = new Double(c); 布尔型包装类对象 boolean b = true; Boolean obj_b = new Boolean(b); 2）字符串转换成包装类对象（更方便） 整型包装类对象 Integer Obj_a = new Ineger(\"1\"); 浮点型包装类对象 Float obj_a = new Float(\"1.2f\"); Double obj_c = new Double(\"1.2d\"); 布尔型包装类对象 Boolean obj_b = new Boolean(\"t\"); 使用字符串转换成包装类对象时，如果传入的字符串不能成功转换成对应的基本数据类型，则会引发异常。 3、将包装类对象转换成基本数据类型（拆箱） 使用xxxValue()方法取出包装类里的对应基本数据类型 取出Integer对象obj_i里的int变量 int a = obj_i.intValue(); 取出Float对象obj_f里的float变量 int b = obj_f.floatValue(); 取出Boolean对象obj_b里的boolean变量 int c = obj_b.booleanValue(); 4、自动装箱和自动拆箱 // 装箱，将整型包装成包装类对象 Integer obj_i = 1; // 拆箱，将包装类对象转换成整型 int i = obj_i; 浮点型包装类，要先进行强制类型转换，在拆箱，不然分不清是float还是double 二、枚举类一个类的对象是有限且固定的，被叫作枚举类。定义枚举类，必须显示的列出所有的枚举值。 定义枚举类： public enum Season { /* 春天、夏天、秋天、冬天 */ SPRING,SUMMER, AUTUMN, WINTER } 定义测试类： public class Test { public static void main(String[] args) { // 取出枚举类的值，并赋值给枚举数组 Season[] ss = Season.values().clone(); // 输出每一个季节 for (int i=0; i&lt;Season.values().length; i++){ System.out.println(ss[i]); } // 输入某个季节 Season a = Season.SPRING; System.out.println(a); } } 三、集合集合是由一组对象组成，集合可以动态改变大小，可以在序列中存储不同的元素。 集合类型 List(列表) 列表区分元素的顺序，允许相同的元素 Set(集) 集不区分元素顺序，不允许相同的元素 Map(映射) 映射是键值对，键不能重复，且一个键对应一个值 1、ArrayList类列表的长度可变，列表允许取值为null。 1）ArrayList类定义： ArrayList&lt;String&gt; al = new ArrayList&lt;String&gt;(); 2）ArrayList类的常用方法 创建ArrayList对象 ArrayList&lt;String&gt; al = new ArrayList&lt;String&gt;(); 获取列表元素个数 al.size(); 将元素添加到末尾 al.add(\"哈哈\"); 将元素添加到指定的位置 al.add(1, \"嘻嘻\"); 查找元素，有则返回true al.contains(\"哈哈\"); 获取元素下标 al.indexOf(\"哈哈\"); 获取下标上的元素 al.get(0); 将下标上的替换 al.set(0,\"嘿嘿\"); 如果列表为空，返回true al.isEmpty(); 删除列表元素 al.remove(\"嘻嘻\"); 删除下标上的元素 al.remove(0); 删除列表的全部元素 al.clear(); 3）列表的基本操作 列表索引 列表对象.get(1) 遍历列表 for (String i: 列表对象) { System.out.println(i); } 列表排序 Collections.sort(列表对象); 2、HashMap类1）HashMap类定义： HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;(); 2）HashMap类的常用方法 // 构造方法 HashMap&lt;String, String&gt; hm = new HashMap&lt;String, String&gt;(); // 成员方法 获取映射大小 hm.size(); 添加键值对 hm.put(\"001\", \"张三\"); 获取键对应的值 hm.get(\"001\"); 查找指定的键，返回true hm.containsKey(\"001\"); 查找指定的值，返回true hm.containsValue(\"张三\"); 如果映射为空，返回true hm.isEmpty(); 删除和键关联的值 hm.remove(\"001\"); 删除所有的映射元素 hm.clear(); 3）映射的基本操作 // 遍历HashMap Iterator iter = hm.entrySet().iterator(); while (iter.hasNext()){ Map.Entry entry = (Map.Entry) iter.next(); System.out.println(\"键：\"+entry.getKey()+\"，值：\"+entry.getValue()); }","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://yanjiuzhe.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"编程语言","slug":"编程语言","permalink":"https://yanjiuzhe.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"Java","slug":"Java","permalink":"https://yanjiuzhe.github.io/tags/Java/"}],"author":"书生"},{"title":"JavaScript","slug":"JavaScript","date":"2021-08-19T07:56:46.000Z","updated":"2021-08-19T08:44:41.033Z","comments":true,"path":"posts/cc1b9611.html","link":"","permalink":"https://yanjiuzhe.github.io/posts/cc1b9611.html","excerpt":"","text":"JavaScript第一章、JavaScript基础语法一、基本语法1、标识符：由字母、数字、下划线、美元符组成，数字不能使首位，不能是关键字。 2、严格区分大小写。 3、代码以空格和括号分隔，以分号结尾。 4、注释：//、/* */ 二、基本数据类型1、number(数值)类型 2、string(字符)类型 3、boolean(布尔)类型 4、object(对象)类型 三、常量与变量1、常量 字符串常量：\"你好，世界！\" 数值型常量：0; 1; 1.5; 布尔型常量：true; false; 特殊常量：空值; 控制字符; 2、变量 定义变量：var 变量名=值; var x,y,z = 10; 3、全局变量与局部变量 &lt;script&gt; var x=10; y=20; // 全局变量 function dome(){ var z=30; // 局部变量 i = 40; //全局变量 } dome(); &lt;/script&gt; 四、输出语句和输入语句1、输出语句 （1）用document对象的write()方法 document.write(); （2）用window对象的alert()方法 alert(); 2、输入语句 （1）用window对象的prompt()方法 prompt(); （2）用文本框输入，使用onBlur事件处理程序得到文本框中的内容 &lt;form name=\"chform\" method=\"POST\"&gt; 请输入：&lt;input type=\"text\" name=\"textname\" onblur=\"test(this.value)\" value=\"\" size=\"10\"&gt; &lt;/form&gt; &lt;script language=\"JavaScript\"&gt; function test(str){ alert(str); } &lt;/script&gt; 五、关键字1、控制流：if-else、for、for-in、while、break、continue、return 2、常数/文字：NaN、null、turn、false、Infinity、NEGATIVE_INFINITY、POSITIVE_INFINTY 3、赋值：=、OP= 4、对象：Array、Boolean、Date、Function、Global、Math、Number、Object、String 5、函数：funtion、Function 6、对象创建：new 7、其他：this、var、with 六、运算符1、算数运算符 +、-、*、%、/、++、– 2、赋值运算符 =、+=、-=、*=、/=、%= 3、字符操作 连接+ 4、比较运算符 ==、!=、&gt;、&lt;、&gt;=、&lt;= 5、逻辑运算符 &amp;&amp;、||、！ 6、三目运算符 1 &lt; 2 ? “正确” : “错误” &lt;p&gt;&lt;h2&gt;算数运算符&lt;/h2&gt;&lt;/p&gt; &lt;p&gt;i = 10, j = 10; i + j = ?&lt;/p&gt; &lt;p id=\"sumid\"&gt;&lt;/p&gt; &lt;button onclick=\"mysum()\"&gt;结果&lt;/button&gt; &lt;script&gt; function mysum() { var i = 10; var j = 10; var m = i + j; document.getElementById(\"sumid\").innerHTML=m; } &lt;/script&gt; 七、条件语句1、条件语句：if - else if - else &lt;p&gt;&lt;h2&gt;条件语句&lt;/h2&gt;&lt;/p&gt; &lt;script&gt; var i = 10; if (i &gt; 0){ document.write(\"i大于0\"); }else if (1==0){ document.write(\"i等于0\"); }else{ document.write(\"i小于0\"); } &lt;/script&gt; 2、条件分支语句：switch &lt;script&gt; var i = 1; switch (i){ case 1: document.write(\"哈哈哈哈\");break; case 2: document.write(\"嘻嘻嘻嘻\");break; case 3: document.write(\"嘿嘿嘿嘿\");break; case 4: document.write(\"呵呵呵呵\");break; case 5: document.write(\"呜呜呜呜\");break; default: document.write(\"条件不满足\");break; } &lt;/script&gt; 八、循环语句1、循环语句：for &lt;script&gt; var i = [1,2,3,4,5]; for (var j=0; j&lt;6; j++){ document.write(i[j]+\"、\"); } &lt;/script&gt; 2、循环语句：while &lt;p&gt;while&lt;/p&gt; &lt;script&gt; var i = 1; while (i&lt;10){ document.write(\"i=\"+i+\"&lt;br/&gt;\"); i++; } &lt;/script&gt; 3、循环语句：do-while &lt;p&gt;do-while&lt;/p&gt; &lt;script&gt; var i = 1; do { document.write(\"i=\"+i+\"&lt;br/&gt;\"); i++; }while (i&lt;10) &lt;/script&gt; 九、跳转语句1、跳转语句：break &lt;script&gt; for (var i=0;i&lt;10;i++){ if (i==5){ break; } document.write(\"i=\"+i+\"&lt;br/&gt;\"); } &lt;/script&gt; 2、跳转语句：continue &lt;script&gt; for (var i=0;i&lt;10;i++){ if (i==5){ continue; } document.write(\"i=\"+i+\"&lt;br/&gt;\"); } &lt;/script&gt; 第二章、函数一、函数简介函数是由事件驱动的，是可重复使用的代码块。 &lt;p&gt;简单函数&lt;/p&gt; &lt;script&gt; // 创建函数 function sum(){、 var a = 10; var b = 10; var c=a+b; alert(s1); } // 调用函数 sum(); &lt;/script&gt; alert()：弹出对话框 二、定义函数// 格式 functio 函数名（）{ 函数体； } // 例子 &lt;p&gt;定义函数&lt;/p&gt; &lt;script&gt; function tell(){ var n = 10; var m = 10; var vl = n*m; alert(vl) } &lt;/script&gt; 三、函数调用第一种方法：直接调用 &lt;script&gt; // 创建函数 function sum(a,b){ var c=a+b; alert(c) } // 调用函数 sum(10,20); &lt;/script&gt; 第二种方法： &lt;script&gt; // 创建函数 function sum(a,b){ var c=a+b; alert(c) } &lt;/script&gt; &lt;button onclick=\"sum(10,20)\"&gt;按钮&lt;/button&gt; 四、带参数的函数函数参数：在函数调用时传递的值，叫参数。 sum(arg1,arg2) // 例子 &lt;p&gt;带参数的函数&lt;/p&gt; &lt;script&gt; function print(name){ alert(\"Hello，我是\"+name); } &lt;/script&gt; &lt;button onclick=\"print('jk')\"&gt;按钮&lt;/button&gt; 五、带返回值的函数&lt;p&gt;带返回值的函数&lt;/p&gt; &lt;p id=\"pid\"&gt;&lt;/p&gt; &lt;script&gt; function hello(){ return \"Hello\"; } document.getElementById(\"pid\").innerHTML=hello(); &lt;/script&gt; return：将值返回 六、内置函数1、数学函数 random：回返0-1区间的随机数 parseInt：将字符转串转换成整数 parseFloat：将字符串转换成浮点数 pow：返回一个幂次方 2、字符串函数 indexOF：返回String对象子字符串第一次出现的位置 lastindexOf：返回String对象子字符串最后一次出现的位置 split：将字符串以指定的字符分割，返回一个数组 3、时间函数 getFullYear 返回年 getDate 返回月 getDay 返回星期 getHours 返回小时 4、常用函数 join 将数组中的元素连接成字符串对象 max 返回两数中较大的数 min 返回两数中较小的数 reverse 反序 第三章、异常处理与事件处理一、异常处理1、异常：当JavaScript引擎执行程序时，发生错误，导致程序停止运行。 2、异常抛出：当异常产生，并将这个异常生成错误信息。 3、异常捕获 try-catch() try{ 发生异常的代码块； }catch(err){ 错误信息处理； } // 例子 &lt;p&gt;异常捕获&lt;/p&gt; &lt;script&gt; function doem(){ try{ alert(str); }catch(err){ alert(err); } } dome(); &lt;/script&gt; 4、自定义异常 throw &lt;p&gt;自定义异常&lt;/p&gt; &lt;!-- 创建文本框和提交按钮 --&gt; &lt;form action=\"\"&gt; &lt;input type=\"text\" id=\"tid\"&gt; &lt;input type=\"button\" onclick=\"dome()\" value=\"按钮\" id=\"bid\"&gt; &lt;/form&gt; &lt;script&gt; function doem(){ try{ var e = document.getElementById(\"tid\").value; if (e = \"\"){ throw \"请输入\"; } }catch(err){ alert(err); } } dome() &lt;/script&gt; 二、事件处理1、事件：事件是可以被JavaScript侦测到的行为。 onClick 单击事件 onMouseOver 鼠标经过事件 onMouseOut 鼠标移出事件 onChange 文本内容改变事件 onSelect 文本框选中事件 onFocus 光标聚集事件 onBlur 移开事件 onLoad 网页加载事件 onUnload 关闭网页事件 2、单击事件 onClick &lt;script&gt; // 创建函数 function sum(a,b){ var c=a+b; alert(c) } // 调用函数 // sum(10,20); &lt;/script&gt; &lt;button onclick=\"sum(10,20)\"&gt;按钮&lt;/button&gt; onclick=\"\" 3、鼠标经过事件 onMouseOver与鼠标移出事件 onMouseOut &lt;div class=\"div\" onmouseout=\"onOut(this)\" onmouseover=\"onOver(this)\"&gt;&lt;/div&gt; &lt;script&gt; function onOver(ooj){ ooj.innerHTML = \"Hello\"; } function onOut(ooj){ ooj.innerHTML = \"World\"; } &lt;/script&gt; 4、文本内容改变事件 onChange &lt;p&gt;文本内容改变事件 onChange&lt;/p&gt; &lt;form action=\"\"&gt; &lt;input type=\"text\" onchange=\"changeDemo(this)\"&gt; &lt;/form&gt; &lt;script&gt; function changeDemo(bg){ alert(\"Hello，内荣改变了\") } &lt;/script&gt; 5、文本框选中事件 onSelect &lt;p&gt;文本框选中事件 onSelect&lt;/p&gt; &lt;form action=\"\"&gt; &lt;input type=\"text\" onselect=\"changeDemo(this)\"&gt; &lt;/form&gt; &lt;script&gt; function changeDemo(bg){ bg.style.background=\"red\"; } &lt;/script&gt; 6、光标聚集事件 onFocus &lt;p&gt;光标&lt;/p&gt; &lt;form action=\"\"&gt; &lt;input type=\"text\" onfocus=\"changeDemo1(this)\"&gt; &lt;/form&gt; &lt;script&gt; function changeDemo1(bg){ bg.style.background=\"blue\"; } &lt;/script&gt; 第四章、文档对象模型-DOM对象一、DOM简介1、HTML DOM：当网页被加载时，浏览器会创建页面的文档对象模型（Documet Object Model） 2、DOM操作HTML： （1）JavaScript能改变页面中的所有HTML元素 （2）JavaScript能改变页面中的所有HTML属性 （3）JavaScript能改变页面中的所有CSS样式 （4）JavaScript能对页面中的所有事件做出反应 二、DOM操作HTML1、改变HTML的输出流： document.write(\"hello\"); 2、寻找元素： （1）通过id寻找元素 getElementById(“id名”); document.getElementById(\"pid\"); （2）通过标签寻找元素 getElementsByTagName(“标签名”); document.getElementsByTagName(\"p\"); 3、改变HTML的内容：innerHTML=”内容” document.getElementById(\"pid\").innerHTML=\"ws\"; 4、改变HTML的属性 &lt;a id=\"aid\" href=\"http://www.baidu.com\"&gt;搜索&lt;/a&gt; &lt;button onclick=\"demo()\"&gt;切换搜索引擎&lt;/button&gt; &lt;script&gt; function demo(){ document.getElementById(\"aid\").href=\"https://cn.bing.com/\"; } &lt;/script&gt; 5、DOM对象操作HTML元素详解 getElementsByName() 获取name getElementsByTagName() 获取元素 getAttribute() 获取元素属性 setAttribute() 设置元素属性 childNodes() 访问子节点 parentNode() 访问父节点 createElement() 创建元素节点 createTextNode 创建文本节点 insertBefore() 插入节点 removeChild() 删除节点 offsetHeight 网页尺寸 scrollHeight 网页尺寸 三、DOM操作CSS1、改变CSS样式 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .div { background-color: red; width: 101px; height: 100px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=\"div\" class=\"div\"&gt; 你好，世界！&lt;/div&gt; &lt;button onclick=\"demo()\"&gt;切换&lt;/button&gt; &lt;script&gt; function demo(){ document.getElementById(\"div\").style.background=\"blue\"; } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 四、DOM EventListener1、向指定元素添加事件句柄：addEventListener(); 2、移除添加的事件句柄：removeEventListener(); &lt;button id=\"btn\"&gt;按钮&lt;/button&gt; &lt;script&gt; var x = document.getElementById(\"btn\"); // 添加句柄 x.addEventListener(\"click\", hello); x.addEventListener(\"click\", world); // 移出句柄 x.removeEventListener(\"click\", hello); function hello(){ alert(\"hello\") } function world(){ alert(\"world\") } &lt;/script&gt; 第五章、事件详解一、事件流1、事件流:描述的是在页面中接受事件的顺序 2、事件冒泡:由最具体的元素接收，然后逐级向上传播至最不具体的元素的节点(文档) 3、事件捕获:最不具体的节点先接收事件，而最具体的节点应该是最后接收事件 二、事件处理1、HTML事件处理:直接添加到HTML结构中。 &lt;div id=\"div\"&gt; &lt;button id=\"btn\"&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;script&gt; function demo(){ alert(\"html事件处理\"); } &lt;/script&gt; 缺点 修改一处，需要修改两处。 2、DOMO级事件处理把一个函数赋值给一-个事件处理程序属性。 &lt;div id=\"div\"&gt; &lt;button id=\"btn\"&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var btn = document.getElementById(\"btn\"); btn.onclick = function(){alert(\"DOM 0级事件处理程序\")}; &lt;/script&gt; 3、DOM2级事件处理 addEventListener(\"事件名\", \"事件处理函数\", \"布尔值\"); true:事件捕获 false:事件冒泡 removeEventListener(); &lt;div id=\"div\"&gt; &lt;button id=\"btn\"&gt;按钮&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var btn = document.getElementById(\"btn\").addEventListener(\"click\", demo) function demo(){ alert(\"DOM 2级事件处理程序\") } &lt;/script&gt; 4、IE事件处理程序 添加事件：attachEvent 移出事件：detachEvent 三、事件对象1、事件对象:在触发DOM事件的时候都会产生一一个对象 2、事件对象event： 1)、type：获取事件类型 2)、target：获取事件目标 3)、stopPropagation()： 阻止事件冒泡 4)、preventDefault()： 阻止事件默认行为 第六章、7、JavaScript内置对象一、对象1、对象简介： 对象是一种数据类型，对象由属性和方法构成。 JavaScript中的所有事物都是对象：字符串、数值、数组、函数… 每个对象带有属性和方法，JavaScript允许自定义对象 2、自定义对象： 1)、 定义并创建对象实例 2)、使用函数来定义对象，然后创建新的对象实例 二、Object对象三、String字符串对象1、String对象：String对象用于处理已有的字符串，字符串可以使用单引号或单引号。 2、常用方法： 在字符串中查找字符串: indexOf() 内容匹配: match() 替换内容: replace() 字符串大小写转换: toUpperCase() / tol owerCase() 字符串转为数组: strong&gt;split() 四、Date对象1、Date对象:日期对象用于处理日期和时间 2、获得当日的日期 var date = new Date(); document.write(date); 3、常用方法: getFullYear():获取年份 getTime():获取毫秒 setFullYear():设置具体的日期 getDay():获取星期 五、Array数组对象1、Array对象:使用单独的变量名来存储一系列的值 2、数组的创建:例: var myArray=[“Hello” ,”iwen”,”ime”]; 3、数组的访问:通过指定数组名以及索引号码，你可以访问某个特定的元素注意: [0] 是数组的第一个元素。[1] 是数组的第二个元素。 4、数组常用方法: concat():合并数组! sort():排序 push():末尾追加元素 reverse():数组元素翻转 六、Math对象1、Math对象:执行常见的算数任务 2、常用方法: round():四舍五入 random():返回0~ 1之间的随机数 max():返回最高值。 min():返回中的最低值。 abs():返回绝对值 第七章、Browser浏览器对象Browser对象是由window、navigator、screen、history、location这五个对象组成，其中window是JavaScript层级中的顶层对象。window是浏览器现象、navigator是客户端浏览器对象、screen客户端显示屏对象、history是浏览器窗口访问历史对象、location是当前URL对象。 一、window对象1、window对象:window对象是BOM的核心，window对 象指当前的浏览器窗口所有JavaScript全局对象、函数以及变量均自动成为window对象的成员全局变量是window对象的属性全局函数是window对象的方法甚至HTML DOM的document也是window对象的属性之一 2、window尺寸: window.innerHeight 浏览器窗口的内部高度 window.innerWidth 浏览器窗口的内部宽度 3、window方法: 1）打开新窗口，参数：页面，名字，打开页面的宽度和高度，打开页面的位置，工具条，菜单 window.open(\"test.html\", \"window_name\", \"width=400\", \"height=200\", \"top=100\", \"left=100\",\"toolbar=no\", \"menubar=no\") 2）关闭当前窗口 window.close() 二、计时器1、计时事件:通过使用JavaScript，我们有能力作到在一个设定的时间间隔之后来执行代码，而不是在函数被调用后立即执行，我们称之为计时事件。 2、计时方法:1）setInterval() -间隔指定的毫秒数不停地执行指定的代码clearInterval() 方法用于停止setInterval()方法执行的函数代码 2）setTimeout() -暂停指定的毫秒数后执行指定的代码clearTimeout() 方法用于停止执行setTimeout()方法的函数代码 三、history对象1、History对象:window.history对象包含浏览器的历史(url)的集合 2、History方法:history.back() -与在浏览器点击后退按钮相同history.forward() -与在浏览器中点击按钮向前相同history.go() -进入历史中的某个页面 四、Location对象1、Location对象：window.location对象用于获得当前页面的地址(URL),并把浏览器重定向到新的页面。 2、L ocation对象的属性: location.hostname 返回web主机的域名 location.pathname 返回当前页面的路径和文件名 location.port 返回web主机的端口 location.protocol 返回所使用的web协议(http:// 或https://) location.href 属性返回当前页面的URL location.assign() 方法加载新的文档 五、Screen对象1、Screen对象：window.screen对象包含有关用户屏幕的信息 2、属性: screen.availWidth -可用的屏幕宽度 screen.availHeight -可用的屏幕高度 screen.Height -屏幕高度 screen.Width -屏幕宽度 第八章、HTML5的新特性一、HTML5的文档结构标签&lt;section&gt; 段落 &lt;nav&gt; 构建导航栏 &lt;header&gt; 页面的页眉 &lt;footer&gt; 页面的页脚 &lt;article&gt; 主体内容 &lt;aside&gt; 边界内容 &lt;hgroup&gt; 段落 &lt;time&gt; 日期/时间 &lt;mark&gt; 重点文字 二、音频和视频标签1、音频标签 &lt;audio src=\"song.mp3\" controls=\"controls\" autoplay=\"autoplay\"&gt; 属性： src 音频URL controls 显示播放按钮 autoplay 自动播放 loop 循环播放 preload 显示加载 2、视频标签 &lt;video src=\"movie.mp4\" width=\"200\" height=\"100\" controls=\"controls\" autoplay=\"autoplay\"&gt; 属性： src 视频URL width 视频播放器宽度 height 视频播放器高度 controls显示播放器控件 autoplay自动播放 loop 循环播放 Spreload显示加载 三、绘图标签 四、其他标签&lt;datalist&gt; 描述细节 &lt;summary&gt; 细节显示 &lt;figcaption&gt;定义&lt;figure&gt;标签的标题 &lt;figure&gt; 段落 &lt;ruby&gt; 解释 &lt;rt&gt; 分隔 &lt;meter&gt; 定义度量衡 &lt;command&gt; 定义命令按钮 &lt;menu&gt; 定义菜单列表","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://yanjiuzhe.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://yanjiuzhe.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://yanjiuzhe.github.io/tags/JavaScript/"}],"author":"书生"},{"title":"HTML5","slug":"HTML5","date":"2021-08-19T07:54:25.000Z","updated":"2021-08-19T08:44:14.155Z","comments":true,"path":"posts/98f3a6d9.html","link":"","permalink":"https://yanjiuzhe.github.io/posts/98f3a6d9.html","excerpt":"","text":"1.HTML5基础知识开发工具：Visual Studio Code HTML5第一章、html5简介1、网页网页的基本组成： –网页是HTML格式的文件，网站是使用HTML,CSS等制作的网页集合。 –基本元素：图片，文字，声音，视频，链接等，以htm或html后缀结尾的文件2、 HTML的认知： –HTML是超文本标记语言，由一套标记标签组成。是一种描述前端的语言。 –所谓超文本：1.超出文本限制，可以加入图片，声音，动画，多媒体等内容（超出文本限制） 2.超级连接文本，可以从一个文化跳到另一个文本上面 3、 Web标准的组成部分：结构html：对网页元素的整理和分类表现css：用于设置网页元素的版式，颜色，大小等外观样式行为Javascript：网页模型的定义和交互的编写 4、html标签之间的关系：包含关系(父子关系)和并列关系(兄弟关系) 5、html的元素：开始标签与结束标签之间的内容，叫元素。 6、html的属性：写在开始标签中的内容，叫属性。 常用标签属性： &lt;body&gt;：bgcolor 背景颜色 &lt;body&gt;：background 背景图片 &lt;h1&gt;：align 对齐方式 &lt;a&gt;：targe 规定打开链接的方法 通用标签属性： class：规定元素的类名 id：规定元素的唯一ID title：规定元素的额外信息 style：规定元素的样式 1、Emmet语法 生成标签：标签名+Tab 生成多个标签：标签名*数量 生成父子级标签：ul&gt;li 生成兄弟级标签：div+span 生成带类名或id名的标签：.类名、#id名 生成顺序div标签：div$5 生成带内容的标签：div{哈哈哈} 第二章、标签一、结构标签：根标签，头部标签，标题标签，主体标签 &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;title/&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; body标签属性： 设置颜色：bgcolor=\"red\" 二、文档类型的声明标签1、HTML的版本号 &lt;!DOCTYPE html&gt; 作用：告诉浏览器使用哪种HTML版本来显示网页，写在第一行。 2.lang语言种类 &lt;html lang=\"zh-CN\"&gt; 作用：用来定义当前文档显示的语言en:英语、zh-CN:中文。 3.字符集：编码类型(UTF-8、GBK...) &lt;meta charset=\"UTF-8\" /&gt; 4.html常用标签： 1.标题2.文本3.图片4.连接5.列表6.表格7.表单8.框架 三、标题标签：1、标题栏标签 &lt;title&gt;&lt;/title&gt; 2、标题标签 标题标签，文字加粗，一行显示&lt;h1&gt;标题&lt;/h1&gt; &lt;h1&gt;&lt;/h1&gt; &lt;h2&gt;&lt;/h2&gt; &lt;h3&gt;&lt;/h3&gt; &lt;h4&gt;&lt;/h4&gt; &lt;h5&gt;&lt;/h5&gt; &lt;h6&gt;&lt;/h6&gt; 标签属性： align:设置对齐方式，值：center、left、right 四、文本标签：1、段落标签： &lt;p&gt;&lt;/p&gt; 作用：分段，段落与段落之间会有间隙&lt;p&gt;分段&lt;/p&gt; 标签属性： align：值：居中对齐：center、左对齐：left、右对齐：right、两端对齐：justify 2、 换行标签： &lt;/br&gt; 3、水平线标签 &lt;hr&gt; &lt;hr size=\"10\" width=\"50%\" align=\"right\" color=\"red\" noshade&gt; 属性： size: 设置水平线粗细 width:设置水平长度 align:设置水平线对齐方式 color:设置水平线颜色 noshade:取消水平线阴影 4、文本格式化标签： 加粗： &lt;b&gt;加粗&lt;/b&gt; 斜体： &lt;i&gt;斜体&lt;/i&gt; 下划线： &lt;u&gt;下划线&lt;/u&gt; 删除线： &lt;s&gt;删除线&lt;/s&gt; 上标： &lt;sub&gt;上标&lt;/sub&gt; 下标： &lt;sup&gt;下标&lt;/sup&gt; 删除线： &lt;del&gt;删除线&lt;/del&gt; 强调字，粗体： &lt;strong&gt;加粗&lt;/strong&gt; 强调字，粗体： &lt;em&gt;加粗&lt;/em&gt; 引用字，斜体： &lt;cite&gt;&lt;/cite&gt; 字体标签：&lt;font&gt; &lt;font size=10 color=\"red\" face=\"黑体\"&gt;你好，世界&lt;/font&gt; 标签的属性： 大小:size 颜色:color 字体:face 5、文字样式： 注释：&lt;!--注释--&gt; 特殊字符： 空格 &amp;#160; &amp;nbsp;空格 &lt; &amp;#60; &amp;lt;小于号 = &amp;#61; 等于符号 &gt; &amp;#62; &amp;gt;大于号 ! &amp;#33; 惊叹号 ” &amp;#34; &amp;quot; 双引号 # &amp;#35; 数字标志 $ &amp;#36; 美元标志 % &amp;#37; 百分号 &amp; &amp;#38; &amp;amp; ‘ &amp;#39; 单引号 ( &amp;#40; 小括号左边部分 ) &amp;#41; 小括号右边部分 * &amp;#42; 星号 + &amp;#43; 加号 , &amp;#44; 逗号 – &amp;#45; 连字号 . &amp;#46; 句号 / &amp;#47; 斜杠 : &amp;#58; 冒号 ; &amp;#59; 分号 ? &amp;#63; 问号 @ &amp;#64; [ &amp;#91; 中括号左边部分 \\ &amp;#92; 反斜杠 ] &amp;#93; 中括号右边部分 ^ &amp;#94; Caret _ &amp;#95; 下划线 ` &amp;#96; { &amp;#123; 大括号左边部分 | &amp;#124; 竖线 } &amp;#125; 大括号右边部分 ~ &amp;#126; Tilde — &amp;#127; 未使用 五、块元素标签与行元素标签：1、块元素显示时，会以新行开始的 &lt;div&gt;、&lt;h1&gt;、&lt;p&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;dl&gt;、&lt;table&gt;、&lt;address&gt;、&lt;blockquote&gt;、&lt;form&gt; （1）&lt;div&gt;标签 &lt;div&gt;&lt;/div&gt; 作用： &lt;div&gt;标签时块元素，主要是组合HTML元素的容器。&lt;div&gt;标签用来布局，独占一行，块级元素，类似于一个超大盒子。 2、行元素标签 &lt;span&gt; &lt;b&gt; &lt;a&gt; &lt;img&gt; &lt;strong&gt;&lt;sub&gt;&lt;sup&gt;&lt;em&gt;&lt;i&gt;&lt;big&gt;&lt;small&gt;&lt;br&gt; &lt;span&gt;组合文档中的行内元素 &lt;input&gt;输入框 &lt;samp&gt;定义样本文本 &lt;var&gt;定义变量 &lt;abbr&gt;表示一个缩写形式 &lt;acronym&gt;定义只取首字母缩写 &lt;bdo&gt;可覆盖默认的文本方向 &lt;cite&gt;引用进行定义 &lt;code&gt;定义计算机代码文本 &lt;dfn&gt;定义一个定义项目 &lt;kbd&gt;定义键盘文本 &lt;label&gt;标签为 &lt;q&gt;定义短的引用 &lt;select&gt;创建单选或多选菜单 &lt;textarea&gt;多行的文本输入控件 &lt;tt&gt;打字机或者等宽的文本效果 （2）&lt;span&gt;标签 &lt;span&gt;&lt;/span&gt; 作用： &lt;span&gt;标签是内联元素，可作为文本容器。&lt;span&gt;标签用来布局，一行可多个&lt;span&gt;标签，行级标签，类似于一个小盒子。 六、图片标签：1、图片标签 &lt;img src=\"图片url\" width=\"500\" height=\"600\" border=\"10\" alt=\"秘密\" title=\"图片\" /&gt; (1). img标签的属性： src：图片路径 width：图片宽度 height：图片高度 border：图片边框的粗细 align：对齐方式 alt：替换文本，当图片不能显示，就会显示文字。 title：提示文本，当鼠标放在图片上，就会显示的文本。 hapace：图片周围水平空白，10px vspace：图片周围垂直空白，10px (2). src后面接图片路径，有绝对路径和相对路径 绝对路径：C:\\Users\\曾钟宁\\Desktop\\Web/a.jpg 网络的绝对路径：https://pics7.baidu.com/feed/fcfaaf51f3deb48f9a5543a351563e212df57864.png?token=cfe6bb0a155ba37ac7ffd7935563c4a5&amp;s=09A062975C5074C61418E06003007077 相对目录：/表示下一级，../表示上一级，../../a.jpg 七、链接标签1、标签 超链接: &lt;a href=\"https://baidu.com\" target=\"目标窗口的弹出方式\"&gt;文本，图片，音频，视频，表格&lt;/a&gt; (1)、a标签的属性： href：指定链接目标的url target属性：&lt;a href=\"www.xxx.com\" target=\"_blank/_self/_parent/_top/framename\"&gt;a&lt;/a&gt; 指定链接页面的打开方式，_self为默认值,当前窗口打开，_blank为新窗口打开。 2、超链接的分类: 外部链接：&lt;a href=\"https://baidu.com\"&gt;百度&lt;/a&gt; 内部链接：网站内部的网页之间的相互连接，&lt;a href=\"文件名.后缀\"&gt;文件&lt;/a&gt; 空连接：&lt;a href=\"#\"&gt;文件&lt;/a&gt; 下载连接：&lt;a href=\"img.zip\"&gt;下载文件.zip/.exe&lt;/a&gt; 网页元素链接：文本，图片，音频，视频，表格 锚点链接：可以快速定位页面中的某个位置 在链接文本的href属性中，设置\"#id\"，&lt;a href=\"#id\"&gt;a&lt;/a&gt; 在目标位置标签里添加一个id属性值，&lt;h3 id=\"id\"&gt;跳转位置&lt;/h3&gt; 八、列表标签：1、 无序列表 &lt;lu&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt; &lt;ul&gt; &lt;li&gt;列表项&lt;/li&gt; &lt;li&gt;列表项&lt;/li&gt; ...... &lt;/ul&gt; &lt;ul&gt;标签属性： 设置符号样式：type = disc:实心圆、circle:空心圆、square:方块、 无序列表是并列关系，&lt;ul&gt;里面只能放&lt;li&gt;标签，&lt;li&gt;标签里面可以容纳所有元素 2、有序列表 &lt;ol&gt; &lt;li&gt;列表项1&lt;/li&gt; &lt;li&gt;列表项2&lt;/li&gt; ...... &lt;/ol&gt; &lt;ol&gt;标签属性 设置序号样式：type = 1、A、a、I 设置起始值：start = 3、 自定义列表 &lt;dl&gt; &lt;dt&gt;列表小标题&lt;/dt&gt; &lt;dd&gt;内容&lt;/dd&gt; &lt;dd&gt;内容&lt;/dd&gt; ...... &lt;/dl&gt; （2）、&lt;dl&gt;标签的属性 九、表格标签作用：展示数据1、表格标签：表头单元格里的文字会加粗的居中 &lt;table&gt; 定义表格 &lt;caption&gt; 定义表格标题 &lt;tr&gt; 定义表格的行 &lt;th&gt; 定义表格的表头 &lt;td&gt; 定义表格的单元 &lt;thead&gt; 定义表格的页眉 &lt;tbody&gt; 定义表格的主体 &lt;tfoot&gt; 定义表格的页脚 &lt;col&gt; 定义表格的列属性 2、 表格的相关属性： tatle标签属性： width：规定表格的宽度 height：规定表格的高度 align：规定表格元素的对齐方式，left、center、right。 border：规定表格单元是否有边框，1、\"\" cellpadding：规定单元边沿与内容之间的空白，默认为1像素 cellspacing：规定单元格之间的空白，默认为2像素 caption标签属性： 设置表格标题位置 align：默认:top、底部:bottom、右边:right tr标签属性： width：规定表格行的宽度 height：规定表格行的高度 align：规定表格行的水平对齐方式，left、center、right。 valign：规定表格行的垂直对齐方式，默认:middle、top、bottom bgcolor：设置表格行的背景颜色 background：设置表格行的背景图 3、td标签属性： 合并行单元格：colspan； 合并行单元格colspan写在最左行 合并列单元格：rowspan；合并列单元格rowspan写在最上列 width：规定表格行的宽度 height：规定表格行的高度 align：规定表格行的水平对齐方式，left、center、right。 valign：规定表格行的垂直对齐方式，默认:middle、top、bottom bgcolor：设置表格行的背景颜色 background：设置表格行的背景图 &lt;table&gt; &lt;tr&gt;&lt;th&gt;表头单元格&lt;/th&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;单元格&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt; 例子 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;表格&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=1 cellpadding=\"0\" cellspacing=\"0\" align=\"center\" width=400px height=200px&gt; &lt;caption&gt;&lt;h2&gt;热门歌曲&lt;/h2&gt;&lt;/caption&gt; &lt;tr&gt; &lt;th align=\"center\"&gt;序号&lt;/th&gt; &lt;th align=\"center\"&gt;名称&lt;/th&gt; &lt;th align=\"center\"&gt;歌手&lt;/th&gt; &lt;th align=\"center\"&gt;时长&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=\"center\"&gt;01&lt;/td&gt; &lt;td align=\"center\"&gt;明年今日&lt;/td&gt; &lt;td align=\"center\"&gt;陈奕迅&lt;/td&gt; &lt;td align=\"center\"&gt;02:34&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td align=\"center\"&gt;02&lt;/td&gt; &lt;td align=\"center\"&gt;青花瓷&lt;/td&gt; &lt;td align=\"center\"&gt;周杰伦&lt;/td&gt; &lt;td align=\"center\"&gt;02:56&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 十、框架标签（已过时）1、框架标签 frame: 2、框架集标签 frameset: 3、常用标签： noresize: 固定框架大小 cols: 列 rows: 行 4、内联框架 iframe: 十一、表单标签：表单的组成：表单域，表单元素，提示信息1、表单域 用于定义表单域，以实现用户信息的搜集和传递 &lt;form&gt;&lt;/form&gt; &lt;form&gt;标签的属性： 属性action：属性值url地址 作用：用于接收并处理表单数据的服务器的url地址 属性method：属性值get/post 作用：用于设置表单数据的提交方式 属性name：属性值名称 作用：用于指定表单域的名称，以区分同一个页面中的多个表单域 2、 表单元素 1）input输入表单元素 &lt;input type=\"属性值\" name=\"元素名\" value=\"请求输入\" checked=\"\" maxlength=\"30\" /&gt; input标签的属性： type、name、value、checked、maxlength 属性type的属性值： text 定义单行的输入字段(文本框)，用户可在其中输入文字 password 定义密码字段，会进行掩码 radio 定义单选按钮，可以实现多选一，必须写上相同的name属性 checkbox 定义复选框，可以实现多选，必须写上相同的name属性 submit 定义提交按钮，可以把表单元素里的值提交给后台服务器 reset 定义重置按钮，可以重置表单中的所有数据 button 定义可点击按钮，(onclick=\"\"，一般通过JavaScript启动脚本) file 定义字段和“浏览”按钮，文件上传用(能上传头像之类的) hidden 定义隐藏的输入字段 image 定义图像形式的提交按钮 属性name=用户自定义 作用：定义input元素的名称 属性value=用户自定义 作用：用于规定input元素的值 属性checked=checked 作用：规定input元素首次加载时应当被选中 属性maxlength=正整数 作用：规定输入字段中字符的最大长度 &lt;label&gt;标签：是input元素定义的标注标签 作用：增加input元素的点击范围 例如： &lt;label for=\"sex\"&gt;男&lt;/label&gt; &lt;input type=\"radio\" name=\"sex\" id=\"sex\" /&gt; 点击按钮后触发的事件 onclick=\"\" 2）select下拉表单元素 &lt;select&gt; &lt;option&gt;选项1&lt;/option&gt; &lt;option&gt;选项2&lt;/option&gt; &lt;option&gt;选项3&lt;/option&gt; ...... &lt;/select&gt; 在&lt;option&gt;中定义select=\"selected\"时，当前项即为默认选中项 3）textarea文本域元素 textarea用于定义多行文本输入的控件(留言板之类的) &lt;textarea rows=\"3\" cols=\"20\"&gt; 文本 &lt;/textarea&gt; 属性rows=\"显示的行数\" 属性cols=\"每行的字符数\" 3、CSS样式引入 1、标签： &lt;style&gt;：样式定义 &lt;link&gt;：样式引用 2、属性： rel=\"stylasheet\" 外部样式表 type=\"text/cass\" 引入样式的类型 margin-left 边距 3、三种样式表插入方法： 外部样式表：&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\"&gt; 内部样式： &lt;style type=\"text/css\"&gt; body {background-color.red} p{margin-left:20px} &lt;/style&gt; 内联样式表： &lt;p style=\"color:red\"&gt;","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://yanjiuzhe.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://yanjiuzhe.github.io/tags/HTML5/"},{"name":"前端","slug":"前端","permalink":"https://yanjiuzhe.github.io/tags/%E5%89%8D%E7%AB%AF/"}],"author":"书生"},{"title":"CSS","slug":"CSS","date":"2021-08-19T07:52:02.000Z","updated":"2021-08-19T08:43:37.964Z","comments":true,"path":"posts/ee69e452.html","link":"","permalink":"https://yanjiuzhe.github.io/posts/ee69e452.html","excerpt":"","text":"第一章、一、CSS规范CSS主要有两个部分构成：选择器和声明。选择器是用于指定HTML标签，花括号是设置该对象的具体样式。 1、CSS三大特性： （1）层叠性 一个标签由多个选择器。当相同选择器设置了相同样式，那么后一个样式会覆盖前一个样式。 （2）继承性 子标签会继承父标签的样式。 （3）优先级 当一个标签多个选择器，当选择器相同，后面的样式会覆盖掉前面的样式。当选择器不相同则会比较权重。 2、元素显示模式 块级标签：一行只能放一个，可以设置宽高，标签内可以包含任何标签。 行内标签：一行可以放多个，不可以设置宽高，标签内只能包含文本或其他行内标签。 行内块级标签：一行放多个行内元素，可以设置宽高。 将行元素转化成块元素：display: block; 将块元素转化成行元素：display: inline; 将元素转换成行内块元素：display: inline-block; 二、CSS的引入方式1、标签： &lt;style&gt;：样式定义 &lt;link&gt;：样式引用 2、属性： rel=\"stylesheet\" 外部样式表 type=\"text/cass\" 引入样式的类型 margin-left 边距 3、三种样式表插入方法： 外部样式表：&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"mystyle.css\"&gt; 内部样式： &lt;style type=\"text/css\"&gt; body {background-color.red} p{margin-left:20px} &lt;/style&gt; 内联样式表： &lt;p style=\"color:red\"&gt; 二、CSS选择器1、标签选择器：写上标签名 1）、定义，指定样式的标签名，统一的为标签设置样式。 p { color: red; } 2）分组 h1 h2 h3 h4 h5 h6 { color: red; } 2、类选择器：样式 . 定义，结构class调用。 1）、定义 .red { color: red; } .size { width: 10px height: 10px; } 2）、调用 &lt;h1 class=\"red\"&gt;啊哈哈哈哈哈&lt;/h1&gt; 3）多类 多类名：一个标签中放多个类样式，每个样式用空格隔开，当类样式有内容重复，后面的会覆盖掉前面的样式。 &lt;h1 class=\"red size\"&gt;啊哈哈哈哈哈&lt;/h1&gt; 3、id选择器：样式#定义，结构id调用。 1）、定义 #blue { color: blue; } 2）、调用 &lt;div id=blue&gt;蓝色&lt;/div&gt; 只能调用一次 4、通配符选择器：样式*定义，自动调用 * { margin: 0; padding: 0; } 自动给所有的标签附上样式 5、属性选择器 定义属性选择器 [title]{ color: blue; } 定义属性和值选择器 [title=\"t1\"]{ color: blue; } 调用 &lt;p title=\"\"&gt;属性选择器&lt;/p&gt; &lt;p title=\"t1\"&gt;属性和值选择器&lt;/p&gt; 6、后代选择器 HTML结构： &lt;p&gt;从明天起，做一个&lt;string&gt;幸福的人&lt;/string&gt;，喂马，劈柴，周游世界&lt;/p&gt; CSS样式： p string{ color: red; } 7、子元素选择器 HTML结构： &lt;ul&gt; &lt;li&gt;&lt;li&gt; &lt;/ul&gt; CSS样式： ul &gt; li { color: red; } 使用&gt;分隔，只能选择子元素。 8、伪类选择器 链接样式： a:link 普通的、未被访问的链接 a:visited 用户以访问的链接 a:hover 鼠标指针位于链接上方 a:active 链接被点击的时刻 光标样式 focus input:focus { background-color: yellow; color: red; } 使用:分隔， 第二章、CSS样式一、背景样式1、 设置元素的背景颜色background-color 定义背景颜色 body { background-color: aqua; } 设置标签背景的背景颜色 .back-color { background-color: blueviolet; width: 30px; padding: 30px; } 设置背景颜色半透明： background: grba(0,0,0,0.5); 2、将图片设置为背景background-image body { background-image: url(../img/bg1.jpg); } # 给标签添加图片 .div-bg { background-image: url(../img/bg1.jpg); } 3、背景图像是否固定或随着页面内容滚动而滚动background-attachment body { background-attachment: fixed; } 默认滚动，滚动:scroll、固定:fixed 4、设置背景图片的起始位置background-position body { background-position: 40px,40px; } #设置百分比0%、25%、50%、100%，设置像素X、Y，设置方位：center、top、left、 5、设置背景图片是否重复以及如何重复background-repeat body { background-repeat: repeat; } repeat:重复、no-repeat:不重复、repeat-x:x轴重复、:repeat-y:y轴重复 6、设置背景图片的大小：background-size body { background-size: 400px,200px; } 适应:autu、 7、设置图片的定位区域：background-origin body { background-origin:border-box; } 8、设置图片的绘制区域：background-clip body { background-clip:content-box; } 二、字体样式1、字体样式 .font { // 字体 font-family: \"仿宋\"; // 字号大小 font-size: 30px; // 字体粗细 font-weight: 100; // 字体样式：无样式:normal、加粗、italic斜体、下划线 font-style: italic; // 定义字母大小写 无样式:normal、小体大写:small-caps font-variant: normal } 2、字体复合属性写法 .font { // font: font-style font-weight font-size font-family font: italic 700 16px \"仿宋\" } 三、文本样式.text-1 { // 文本颜色 color: darkred; // 对齐方式 text-align: center; // 装饰文本 text-decoration: underline; // 首行缩进 text-indent: 2em; // 文本行间距 line-height: 20px; // 字母处理 text-transform: capitalize; // 阴影效果：水平距离、垂直距离、清晰度、颜色 text-shadow: 20px 20px 1px F00; } 对齐方式：center:居中对齐、left:左对齐、right:右对齐、justify:两端对齐。 装饰文本：none:无、line-through删除线、underline:下划线、overline上划线 em：相对于当前像素的一个文字大小。 字母处理：capitalize:首字母大写、lowercase:全部小写、uppercase:全部大写 阴影效果：10px:距右距离，10px:距下距离、清晰度2px、颜色#00 四、列表样式1、列表类型：list-style-type li { list-style-type: georgian; } 空心圆circle、方块square、数字decima、鬼画符georgian 2、列表项图像：list-style-image li { list-style-image: url(\"../img/花瓣.png\"); } 3、列表标志位置：list-style-position li { list-style-position: inside; } li { list-style-position: outside; } 将列表横放:display: inline; 五、表格样式1、设置表格外边框 border #ta tr th td { border: 5px solid blue violets; } 2、合并边框 border-collapse #ta { border-collapse: collapse; } 3、设置表格内边距 padding td { padding: 10px; } 4、设置宽和高 #ta { width: 400px; height: 400px; } 5、设置对齐方式text-align #ta { text-align: center; vertical-align: middle; } 设置水平对齐 text-align: left、right、center 设置垂直对齐 vertical-align: top、bottom、middle 6、设置表格颜色 #ta { background-color: aqua } 六、超链接样式1、超链接的状态 a:link 普通的、未被访问的链接 a:visited 用户以访问的链接 a:hover 鼠标指针位于链接上方 a:active 链接被点击的时刻 2、超链接的样式 // 除去链接中的下划线 text-decoration a:link { // 除去链接中的下划线 text-decoration: none; // 设置背景颜色 background-color: red; // 设置前景色 color:#F000 } 七、1、鼠标样式 cursor .div { cursor: wait; } cursor属性： 自动默认选择：auto 正常选择：default 移动：move 忙：wait 水平调整：w-resize 垂直调整：s-resize 连接选择：pointer 精准定位：crosshair 连接选择：hand 帮助选择：help 文本选择：text 水平调整：e-resize 垂直调整：n-resize 外部连接鼠标样式：url 沿对角线调整：ne-resize、sw-resize、se-resize、nw-resize 2、光标样式 focus input:focus { background-color: yellow; color: red; } 3、滚动条 overflow （1）overflow属性 自动显示滚动条 overflow: auto; 没用滚动条 overflow: hidden; 没有水平滚动条 overflow-x: hidden; 没有垂直滚动条 overflow-y: hidden; .div { overflow-x:hidden; overflow-y: hidden; overflow: hidden; overflow: auto; } （2）设置滚动条颜色 顶部/底部图标颜色 scrollbar-arrow-color: black; 滚动条颜色 scrollbar-face-color: black; 滚动条阴影颜色 scrollbar-shadow-color: black; 滚动条背景颜色 scrollbar-track-color: black; 滚动条基本颜色 scrollbar-base-color: black; 4、滤镜 filter 1、设置透明度 alpha filter: alpha(10) 2、设置模糊滤镜 blur(Npx) filter: blur(4px); 3、设置亮度 brightness(%) filter: brightness(2%); 4、设置对比度 contrast(%) filter: contrast(30%); 5、饱和度saturate(%) filter: saturate(20%); 6、投影dropShadow(color=颜色, offX=x偏移, offY=y偏移, positive模糊范围) filter: dropShadow(2px 10px 0 rgba(255,0,0,0.5)); 7、设置水平反转 flipH filter: flipH; 8、设置垂直反转 flipV filter: flipV; 9、设置外发光 glow(color=颜色,strength=强度) filter: glow(color=red, strength=10) 10、灰度 gray(%) filter:gray(0.5); 11、设置波纹效果 wave(add=1, ) filter:wave(1); 12、色相旋转hue-rotate(deg) filter:hue-rotate(125deg); 第三章、盒子模型布局1、组成：内容、内边距、边框、轮廓、外边距 一、内边距 padding// 设置所有边距 padding .tdbj { padding: 100px; } .tdbj { // 设置上边距 padding-top padding-top: 100px; // 设置底边距 padding-botton padding-botton: 100px; // 设置左边距 padding-left padding-left: 100px // 设置右边距 padding-right padding-right: 100px } 二、边框样式 border1、边框的样式 border-style .div1 { border-style: dotted; } 2、边框的单边样式 border-top-style: ; border-left-style: ; border-right-style: ; border-bottom-style: ; none:无样式、double:双线样式、solid:实线样式、dotted虚线样式、inset:3D凹边、outset:3D凸边 3、边框的粗细 border-width .div1 { border-width: 10px; } 单边框粗细 border-top-width border-left-width border-right-width border-bottom-width 4、边框颜色 border-color .div1 { border-color: red; } 5、圆角边框 border-radius .div1{ border-radius: 10px; } # 设置单边圆角 .div1{ border-radius: 10px 20px 30px 40px; } 6、边框阴影 box-shadow .classid { // 设置边框阴影：距右距离、距下距离、阴影尺寸、清晰度、颜色、内部颜色 box-shadow: 10px 10px 5px 5px #FF00 inset } 默认外阴影、inset内阴影 7、合并边框 -border-collapse #ta { border-collapse: collapse; } 三、轮廓样式 outline1、设置轮廓属性 outline: p { // 1、设置轮廓属性 outline: // 2、设置轮廓的颜色 outline-color: red; // 3、设置轮廓的样式 outline-style: groove; // 4、设置轮廓的宽度 outline-width: 10px; } outline-style属性：无样式:none、dotted:定义点状的轮廓、dashed:定义虚线轮廓、solid:定义实线轮廓、double:定义双线轮廓。 四、外边距 margin.div { // 外边距 margin: 10px; // 顶部外边距 margin-top: 10px; // 底部外边距 margin-bottom1```: 10px; // 左边外边距 margin-left: 10px; // 右边外边距 margin-right: 10px; } 清除内外边距： * { padding: 0; margin: 0; } 第四章、浮动布局一、CSS定位1、定位机制： 绝对定位：position: absolute; 相对定位：position: relative; 普通流：元素按照HTML的默认位置顺序决定排布的过程。浮动流：脱离普通流的控制，浮动流的盒子不会保留原先的位置。绝对布局： 一、普通流 position1、普通流：元素按照HTML的位置顺序决定排布的过程。 2、属性 // 设置元素放置的位置上 position div { position: static; } （1）、position的值： 静态:static、相对:relative、绝对:absolute、固定:fixed （2）、相对位置可以设置偏移量： // 元素向上的偏移量：top // 元素下的偏移量：bottom // 元素向左的偏移量：left // 元素向右的偏移量：right （3）、设置元素溢出区域发生的事：overflow （4）设置元素显示的形状：clip （5）设置元素垂直对齐的方式：vertical-align （6）设置元素的堆叠顺序：z-index div { position: static; z-index: 1; } 二、浮动流 float1）float的值： // 元素不浮动 none // 元素向左浮动 left // 元素向右浮动 right // 从父级继承浮动属性 inherit div{ float: none; } 2）clear属性 去掉浮动属性 div{ clear: both; } clear属性值: both去掉左右两侧浮动、laft去掉向左浮动、right去掉向右浮动、inherit去掉父级继承浮动 3）设置元素的堆叠顺序：z-index div { z-index: 1; } 浮动样式应用 HTML结构 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;瀑布流布局&lt;/title&gt; &lt;link href=\"浮动应用样式.css\" type=\"text/css\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"../img/花瓣.png\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"../img/花瓣.png\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"../img/花瓣.png\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"../img/花瓣.png\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"../img/花瓣.png\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"../img/花瓣.png\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"../img/花瓣.png\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"../img/花瓣.png\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"../img/花瓣.png\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; CSS样式 *{ margin: 0px; padding: 0px; } li { list-style: none; } #div1 { width: 1000px; height: auto; margin: 20px auto; } ul{ width: 250px; float: left; } 第五章、CSS常见操作一、对齐操作1、使用margin属性进行水平对齐 .div { margin-left: auto; margin-right: auto; } 2、使用position属性进行左右对齐 .div { position: absolute; // 向左对齐 left: 0px; // 向右对齐 right: 0px; } 3、使用float属性进行左右对齐 div{ float: left; float: right; } 二、分类1、尺寸 设置元素高度 .p{ // 设置元素高度 height: 10px; // 设置元素宽度 widht: 10px; // 设置行高 lie-height: 10px; } 2、分类 设置鼠标样式 cursor .p{ cursor: alias; } 设置元素是否可见 visibility li { visibility: visible; } visible:可见、hidden不可见 三、导航栏1、垂直导航栏 HTML结构 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;导航栏&lt;/title&gt; &lt;link href=\"导航栏样式.css\" type=\"text/css\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"https://www.baidu.com/\"&gt;百度&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.sogou.com/\"&gt;搜狗&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.bilibili.com/\"&gt;bilibili&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.zhihu.com/\"&gt;知乎&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; CSS样式 ul{ list-style: none; margin: 0px; padding: 0px; } a:link,a:visited{ text-decoration: none; display: block; background-color: aqua; width: 50px; text-align: center; } a:active,a:hover{ background-color: bisque; } 2、水平导航栏 HTML结构 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;导航栏&lt;/title&gt; &lt;link href=\"导航栏样式.css\" type=\"text/css\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"https://www.baidu.com/\"&gt;百度&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.sogou.com/\"&gt;搜狗&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.bilibili.com/\"&gt;bilibili&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"https://www.zhihu.com/\"&gt;知乎&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; CSS样式 ul{ list-style: none; margin: 0px; padding: 0px; background-color: darkgray; width: 250px; text-align: center; } a:link,a:visited{ font-weight: initial; text-decoration: none; background-color: aqua; width: 50px; text-align: center; } a:active,a:hover{ background-color: bisque; } li { display: inline; padding: 3px; padding-left: 5px; padding-right: 5px; } 四、图片样式HTML结构 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;图片样式&lt;/title&gt; &lt;link href=\"图片样式1.css\" type=\"text/css\" rel=\"stylesheet\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;div class=\"image\"&gt; &lt;a href=\"#\" target=\"_self\"&gt; &lt;img src=\"../img/时崎狂三.jpg\" alt=\"风景\" width=\"400px\" height=\"200\"&gt; &lt;/a&gt; &lt;div class=\"text\"&gt;时崎狂三&lt;/div&gt; &lt;/div&gt; &lt;div class=\"image\"&gt; &lt;a href=\"#\" target=\"_self\"&gt; &lt;img src=\"../img/时崎狂三.jpg\" alt=\"风景\" width=\"400px\" height=\"200\"&gt; &lt;/a&gt; &lt;div class=\"text\"&gt;时崎狂三&lt;/div&gt; &lt;/div&gt; &lt;div class=\"image\"&gt; &lt;a href=\"#\" target=\"_self\"&gt; &lt;img src=\"../img/时崎狂三.jpg\" alt=\"风景\" width=\"400px\" height=\"200\"&gt; &lt;/a&gt; &lt;div class=\"text\"&gt;时崎狂三&lt;/div&gt; &lt;/div&gt; &lt;div class=\"image\"&gt; &lt;a href=\"#\" target=\"_self\"&gt; &lt;img src=\"../img/时崎狂三.jpg\" alt=\"风景\" width=\"400px\" height=\"200\"&gt; &lt;/a&gt; &lt;div class=\"text\"&gt;时崎狂三&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; CSS样式 body { margin: 10px auto; width: 70%; height: auto; } .image { border: 1px solid darkgray; width: auto; height: auto; float: left; text-align: center; margin: 5px; } img { margin: 5px; } .text { font-size: 12px; margin-bottom: 5px; } 第六章、CSS动画一、3D与2D的转换实现一些效果，例如移动、旋转、缩放、倾斜、拉伸 1、2D转换的方法： translate() 移动 rotate() 旋转 scale() 缩放 skew() 倾斜 matrix() 拉伸 /* 移动 */ .div1 { transform: translate(200px,100px); /* 指定浏览器 */ -ms-transform: translate(100px,100px); /*IE*/ } /* 旋转 */ .div1 { transform: rotate(200deg); /* 指定浏览器 */ -ms-transform: translate(100px,100px); /*IE*/ } /* 缩放 */ .div1 { transform: scale(1,2); /* 指定浏览器 */ -ms-transform: translate(100px,100px); /*IE*/ } /* 倾斜 */ .div1 { transform: skew(30deg, 20deg); /* 指定浏览器 */ -ms-transform: translate(100px,100px); /*IE*/ } /* */ .div1 { transform: matrix(1,2,3,4,5,6); /* 指定浏览器 */ -ms-transform: translate(100px,100px); /*IE*/ } 2、3D转换的方法： rotateX() rotateY() /* */ .div1 { transform: rotateX(500deg); /* 指定浏览器 */ -ms-transform: translate(100deg); /*IE*/ } /* */ .div1 { transform: rotateY(500deg); /* 指定浏览器 */ -ms-transform: translate(100deg); /*IE*/ } 二、过度是元素从一种样式转换成另一种样式。 // 设置过度 transition // 过度名称 transition-property // 过度效果的时间 transition-duration // 过度效果的时间曲线 transition-timing-functio // 过度效果的延时时间 transition-delay // 实战- div { width: 100px; height: 100px; background-color: darkturquoise; -webkit-transition: width 2s, height 2s, -ms-transform 2s; transition: width 2s, height 2s, transform 2s; -webkit-transition-delay: 2s; transition-delay: 2s; } div:hover { width: 200px; height: 200px; transform: rotate(360deg); -ms-transform: rotate(360deg) } 三、动画遵循@keyframes规则：规定动画时长、规定动画名称 四、多列对文本或区域进行布局 column-count 分列的数量 column-gap 列间距 column-rule 间距线 &lt;!DOCTYPE html&gt; &lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;title&gt;多列&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"多列样式.css\" type=\"text/css\"&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=\"div1\"&gt; 哈啊哈哈哈哈哈哈哈 哈啊哈哈哈哈哈哈哈 哈啊哈哈哈哈哈哈哈 哈啊哈哈哈哈哈哈哈 哈啊哈哈哈哈哈哈哈 哈啊哈哈哈哈哈哈哈 哈啊哈哈哈哈哈哈哈 哈啊哈哈哈哈哈哈哈 哈啊哈哈哈哈哈哈哈 哈啊哈哈哈哈哈哈哈 哈啊哈哈哈哈哈哈哈 哈啊哈哈哈哈哈哈哈 哈啊哈哈哈哈哈哈哈 哈啊哈哈哈哈哈哈哈 哈啊哈哈哈哈哈哈哈 哈啊哈哈哈哈哈哈哈 哈啊哈哈哈哈哈哈哈 哈啊哈哈哈哈哈哈哈 哈啊哈哈哈哈哈哈哈 哈啊哈哈哈哈哈哈哈 哈啊哈哈哈哈哈哈哈 &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; .div1 { column-count: 4; -webkit-column-count: 4; -webkit-column-gap: 30px; column-gap: 30px; column-rule: 5px outset red; -webkit-column-rule: 5px outset red; }","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://yanjiuzhe.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://yanjiuzhe.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"CSS","slug":"CSS","permalink":"https://yanjiuzhe.github.io/tags/CSS/"}],"author":"书生"},{"title":"Linux基础","slug":"Linux基础","date":"2021-08-18T01:39:00.000Z","updated":"2021-08-19T08:45:18.426Z","comments":true,"path":"posts/a4a81253.html","link":"","permalink":"https://yanjiuzhe.github.io/posts/a4a81253.html","excerpt":"","text":"第一章、Linux系统管理一、Linux命令基础1． 打开命令行 ：centos桌面左键，选择poenterminal, 2、命令行的组成：命令 【选项/参数】【操作对象】 [root@master ]# root:当前用户名、@:分隔符、master:Linux系统名、:当前目录、# root权限（$普通权限） 3、命令、参数、操作对象之间有空格分隔；使用分号结尾，可在一行输入多个命令；可以用反斜杠“\\”断开命令。 4、【Tab】键可以“命令补齐”和“文件补齐” 5、 | 管道符 6、 / 搜索符 ​ /string 查找string这个字符串 7、 Ctrl+C 终止当前程序 8、 Ctrl+G 进入系统输入 9、 Ctrl+Alt 返回计算机 10、 Ctrl+z 11、 Ctrl+L 清屏 二、Linux系统管理命令1、Linux系统管理命令（1) uname -a 查看系统全部命令，包括内核、版本号、操作系统类型 （2) halt命令 关机 （3) init 0 关机 （4) init 6 重启 （5) init 3 命令界面 （6) init 5 图形界面 （7) reboot命令 重启系统 （8) poweroff命令 停止系统并关闭电源 （9）shutdown命令 ​ shutdown 选项/时间 作用 参数： ​ -r now / +5 / 8:00 重启系统 ​ -h now / +5 / 8:00 关闭系统 date 查看系统时间 ​ date “%Y-%m-%d %H:%M:%S 获取当前时间 ​ date %s 获取时间戳” ​ date -s 2021.5.0520 设置系统日期 ​ -s 12:00 设置系统时间 （11) free -h 查看系统内存使用情况 （12) pidof 操作对象 查看某个服务进程的PID值 （13) kill PID 向进程发送一个信号 参数： ​ -1 PID 关掉电话线 ​ -2 PID 结束进程 ​ -9 PID 强制结束进程 ​ -15 PID 正常结束进程 ​ -19 PID 暂停结束进程 （14) kill all [选项] [进程名] 结束某个指定的服务对应的进程 （15) alias 命令别名=命令 用于查询和设置命令的别名 ​ 列：alias tm=date （16) ps 查看系统进程状态（五种常见的进程状态：运行R、中断S、不可中断D、僵死Z、停止T） ​ 参数： ​ -a 显示所有进程 ​ -u 查看系统进程用户名和启动时间 ​ -x （17) wget [选项] [资源url地址] 下载资源 （18) top 动态查看进程活动和系统负载 （19) who 查看当前登录主机的用户 （20) last 查看所有登录系统的记录 （21) wget [选项] [资源url地址] 下载资源 （22）clear 清屏 （23) IP addr 查看IP （24) Ifconig [网络设置] [参数] 获取网卡配置和网络状态 （25) ping 查看网络状态 （26）网卡信息 ​ 网卡配置文件：/etc/sysconfig/network-scripts/ifcfg-ens33 ​ 地址分配模式：BOOTPROTO=static | dhcp | none:表示无须启动协议 | bootp:表示使用BOOTP协议 ​ 是否开机自启：ONBOOT=yes | no ​ IP地址：IPADDR=192.168.10.10 ​ 子网掩码：NETMASK=255.255.255.0 或 PREFIX=24 ​ 网关地址：GATEWAY=192.168.10.1 ​ DNS地址：DNS1=192.168.10.1 （26) source 文件名 使配置文件生效 （27) hostname 查询当前系统主机名 ​ hostname [名字] 临时修改主机名 ​ hostnamectl set-hostname [名字] 永久修改主机名 （28） jps 查看当前用户启动的Java信息 （29）export [选项] [变量名] 功能：用于将 Shell 变量输出为环境变量，或者将 Shell 函数输出为环境变量。 （30）echo 命令功能：用于在终端设备上输出字符串或变量提取后的值。一般使用在变量前 加上$符号的方式提取出变量的值，格式：echo [字符串] 2、Linux的帮助命令（help、man、info）（1）help命令： help 命令（用于内部命令） –help命令（用于外部命令） （2）man命令 按键 功能 ​ 空格键 向下翻页 ​ page down 向下翻页 ​ page up 向上翻页 ​ home 到第一页 ​ end 到最后一页 （3）info 命令 显示内容更完整 3、历史命令：history命令 选项/参数 操作对象 作用 history -ps 显示或操纵历史列表 ​ -anrw 文件名 显示或操纵历史列表 ​ -c 清空历史列表 ​ -d 偏移量 从指定位置删除历史列表 ​ -a 将当前历史行添加到历史文件 ​ -n ​ -r ​ -w ​ -p ​ -s 第二章、Linux目录管理一、目录的四种类型1、可分享目录： 分享给其他系统挂载使用的目录 2、不可分享目录： 系统运行的配置文件或程序有关的socket文件 3、可变目录： 经常改变数据的目录，如：登录文件 4、不可变目录： 不经常改变的数据，如：函数库，系统主机服务配置文件 二、目录结构树形结构：/ 三、目录路径1、概念：系统中存放文件或目录的位置 2、相对路径：相对于当前所在路径的位置 3、绝对路径：从根目录开始，依次将各级子目录的名字组合的路径 4、路径中的特殊符号 ​ . :表示用户所处的当前目录 ​ .. :表示上级目录 - :表示前一个目录 ​ ~ :表示家目录 ​ / :表示根目录 四、显示路径（pwd）​ pwd 显示当前目录的路径 五、切换目录（cd）cd [目录名/特殊符号] 将当前目录切换到指定目录 ​ 目录名 切换到指定目录 ​ 空白 切换到家目录 ​ ~ 切换到家目录 ​ — 切换到上一次操作目录 ​ .. 切换到上一级目录 路径 切换到路径对应的目录 六、查看目录/文件（ls、ll）​ ls 参数 目录名 查看指定目录下的子目录和文件 参数 ​ -a 查看所有文件和目录，包括隐藏文件（隐藏文件前面带**.**） ​ -d 查看目录，但不显示文件 ​ -l 将权限、拥有者、文件大小全部列出（ll=ls -l） ​ -r 将文件以英文反次序显示 ​ -t 将文件以建立的先后顺序列出 ​ -A 同-a，但不列出当前目录以及上一级目录 ​ -R 诺目录下有文件，则以文件次序列出 七、创建目录（mkdir）​ mkidr 参数 目录名 参数： ​ -m 为目录指定访问权限，与chmod类似 ​ -p 如果父目录存在，不会报错，不存在就会创建父目录（创建多级目录） ​ -v 显示指令执行的过程 ​ {目录1，目录2} 同时创建多个目录 八、删除目录/文件（rm）1、作用：删除目录，但只能删除空目录或多级空目录 rmdir [选项] 目录名 ​ -p 递归删除目录，删除多级目录 ​ -v 显示执行细节 ​ {目录1，目录2} 删除多级目录 rm -r 目录名 删除目录 rm -rf 目录/文件 强制删除目录或文件 第三章、Linux文件管理一、创建文件（touch、vi）​ touch 参数 文件 参数： ​ touch 创建文件 ​ touch -c 更改文件访问时间 ​ touch {文件1,…文件5}.text 同时创建多个时间 二、编辑文件（vi）vi 创建文件，文件不存在，则打开文件 命令模式：常用命令 / 搜索(区分大小写) n 查找下一个 :nu 显示当前文件行号 :wq 保存退出（q保存、w退出、!强制） Esc 退到命令行 i 进入编辑模式 o 跳转到下一行编辑 yy 复制 p 粘贴到下一行 dd 删除当前行 999dd 删除光标以后的全部内容 gg 跳转到文件首行 G 跳转到文件尾行 u 撤销操作 修改文件 echo ‘要修改的字符串‘ &gt;&gt; filename 二、查看文件内容（cat、head、tail、more、less）1、cat命令（查看文件全部内容） ​ Cat 参数 文件 参数： ​ -n 由1开始，对所有的行号进行编号 ​ -b 与1类似，但对空白行不进行编号 ​ -s 当遇到连续两行以上的空白行，则只输出一行。 ​ -n /test/目录1 &gt; /test/目录2 将目录1的文件添加到目录2 ​ /test/目录1 /test/目录2 &gt; /test/目录3 将目录1和目录2的文件合拼到目录3 2、head命令（显示文件前十行） 3、tail命令（显示最后十行） 4、 more（ 以一页一页的形式显示文件：空格键：下一页、b：上一页 ） 5、less命令（ less 与 more 类似，less 可以随意浏览文件，支持翻页和搜索，支持向上翻页和向下翻页。 ） 三、移动文件/目录（mv）mv 文件 目标目录 mv 修改文件夹名/目录名 修改文件名/目录名：mv 文件名/目录名 新文件名/新目录名 四、复制文件/目录（cp）​ cp 参数 源文件 目标文件 参数： ​ —r 递归复制目录下所有目录/文件 ​ —f 强制复制文件，若重名直接覆盖 五、删除目录/文件（rm）1、作用：删除目录，但只能删除空目录或多级空目录 rmdir [选项] 目录名 ​ -p 递归删除目录，删除多级目录 ​ -v 显示指令执行的过程 ​ {目录1，目录2} 删除多级目录 rm -r 目录/文件 删除目录 rm -rf 目录/文件 强制删除目录或文件 六、查找文件（find）find 路径 参数 文件名 参数： name : name按名字查找、iname 会忽略大小写 size n : 按文件大小查找 七、修改文件的权限（chmod）chmod 777 文件名/目录名 （读：4、写：2、执行：1） chmod u=rwx,g=rw,o=r 文件名/目录名 （读：r、写：w、执行：x） u所有者，g 表示与所有者同组用户，o 表示其他用户。 八、tar 命令（打包/解压）格式：tar [选项] [档案名] [文件或目录] 打包： tar -cvf 目标包.tar 源包.log 解压：tar -zxvf 包名 参数： -c 创建压缩文件 -x 解开压缩文件 -z 用gzip压缩或解压文件，文件名为*.tar.gz。 -f &lt;备份文件&gt; 指定备份文件。 -v 显示压缩或解压的过程。 -C 指定解压到的目录 -t ：查看打包文件的内容含有哪些文件 stat—查看文件详细信息，包括存储信息和时间等 stat a.text cut—按列提取文本字符，而head是按行取文本 diff—比较两个文本文件是否相同 语法：diff [选项] 文本文件 diff -c a2 a2 第四章、用户操作一、基本简介管理员UID为0：系统的管理员用户。系统用户UID为1～999： 默认服务程序会有独立的系统用户负责运行。普通用户UID从1000开始：是由管理员创建的用于日常工作的用户。 二、添加新用户（useradd）功能：创建新用户，该命令只能由 root 用户使用。 创建 teacher 用户 [root@master ~]# adduser teacher 参数： -d 指定用户的家目录（默认为/home/username）-e 账户的到期时间，格式为YYYY-MM-DD.-u 指定该用户的默认UID-g 指定一个初始的用户基本组（必须已存在）-G 指定一个或多个扩展用户组 三、用户管理1、groupadd命令 创建用户组[root@master ~]# groupadd jxjd 2、修改用户或组（chown） 功能：将文件或目录的拥有者改为指定的用户或组，[root@master ~]# chown bin:bin a.txt 3、usermod命令 修改用户属性语法：usermod [选项] 用户名 参数： -d -m与参数-d连用，可重新指定用户的家目录并自动把旧的数据转移过去-e 账户的到期时间，格式为YYYY-MM-DD-g 变更所属用户组-G 变更扩展用户组-L 锁定用户禁止其登录系统-U 解锁用户，允许其登录系统-u 修改用户的UID 4、修改密码（passwd） 功能：设置或修改指定用户的密码。 更改用户 teacher 的密码 。 [root@master ~]# passwd teacher 更改用户 teacher 的密码 。 5、userdel命令 删除用户 [root@ local ~]# userdel -r zzn 参数： -f 强制删除用户 -r 同时删除用户及用户家目录 四、切换用户（su）su 命令 [root@master ~]# su teacher [root@master ~]# su teacher 五、提升用户权限（Sudo）[root@master ~]# sudo teacher 第五章、文件操作1、统计字符数（wc）wc -[选项] 文件 参数： -c 显示字节数 -m 显示单词数 -l 显示行数 -L 最长字符行的字符数 -m 单词个数 -c and -m （包含换行符和空格） 2、排序（sort） sort -[选项] 文件 参数： -n 按字典序排序 -r -k 3、检查重复行列（uniq） uniq -[选项] 文件 参数： -c 重复次数 -n 返回不重复的 4、查找：grep 常用于查找文件里符合条件的字符串 grep -[选项] 文件 参数： grep -i 忽略大小写 grep -v 忽略包含指定字符串的数据 grep -n 显示对应字符串的行号 5、编辑：sed 用来自动编辑一个或多个文件、简化对文件的反复操作 sed [选项] 文件 参数： sed -a/i 增加：a行后增加、l行前增加、$最后一行增加 sed -d 删除 sed -s 替换 sed -l 修改原文件 6、分析：awk 是一种处理文本的语言，是一个强大的文本分析工具 第六章、shell编程 #!/bin/bash 开头文件 echo hello world 脚本内容 # 执行脚本 1. bash/sh 脚本文件 可选项: -x 输出要执行的脚本内容，再输出脚本结果 2. ./脚本文件 -需要添加执行用户权限(chmod u+x 脚本文件) 3. 脚本文件 -需要添加环境变量 .:$PATH # shell变量 1. 本地变量 格式: VAR_NAME=VALUE 应用场景: 在shell脚本中定义一些临时变量时使用，对当前shell进程的子shell进程及其它shell进程无效 2. 环境变量 格式: export VAR_NAME=VALUE 应用场景: 用于设置临时环境变量, 对子shell进程有效，对其它shell进程无效 3. 位置变量 $1、$2、$3 -shell脚本内容 格式: xxx.sh abc xyz 位置变量相当于java中main函数的args参数，可以在shell脚本中动态获取外部参数 4. 特殊变量 $? -上一条命令的返回状态码，状态码在0~255之间(0表示成功，其它为失败) $# -shell脚本所有参数的个数 变量和引号 单引号不解析变量 注意单引号不解析变量，以下反引号中的`$name`不是单引号 双引号解析变量 反引号: `$name`解析变量，并以获取到的值转为命令执行, 另一种写法$($name) 拼接单引号, 例 echo \"'name'\" # shell循环 for((i=0;i&lt;10;i++)) -如果do写在for后面需要先加; do 循环体 done for i in 1 2 3 do 循环体 done while 测试条件 do 循环体 done 测试条件: 1. text 表达式 2. [ 表达式 ] 表达式: -gt(大于)、-lt(小于)、-ge(大于等于)、-le(小于等于)、-eq(等于)、-ne(不等于)、=(等于)、!=(不等于) e.g: while [ 2 -gt 1 ] do echo yes sleep 1 # 休眠1秒 done # 单分支 if 测试条件 then 选择分支 fi # 双分支 if 测试条件 then 选择分支1 else 选择分支2 fi # 多分支 if 测试条件1 then 选择分支1 elif 测试条件2 then 选择分支2 ... else 选择分支n fi e.g #!/bin/bash if [ $# -lt 1 ] # 判断外部参数个数是否为1 then echo not found param exit 100 # 退出脚本执行，不会执行下面的代码，100是自定义状态码，echo$?命令 fi flag=$1 if [ $flag -eq 1 ] then echo yes fi 脚本运行命令: nuhup xxx.sh &amp; -nohup表示即使关掉此回话也不会停止shell脚本运行， &amp;表示后台运行 #重定向 &gt; 覆盖， &gt;&gt; 追加 例如 ll &gt; a.txt # 将ll显示的信息添加到a.txt中 # 定时器 crontab systemctl status crond # 查看服务状态 /etc/crontab # 配置文件路径 tail -f /var/log/cron # 检测日志文件 第七章、linux中systemctl详细理解及常用命令：Linux 服务管理两种方式service和systemctlsystemd是Linux系统最新的初始化系统(init),作用是提高系统的启动速度。systemd对应的进程管理命令是systemctlsystemctl命令管理systemd的资源Unitsystemctlsystemctl –-version 查看版本号 systemctl start：立刻启动后面接的 unit。 systemctl stop：立刻关闭后面接的 unit。 systemctl restart：立刻关闭后启动后面接的 unit，亦即执行 stop 再 start 的意思。 systemctl reload：不关闭 unit 的情况下，重新载入配置文件，让设置生效。 systemctl enable：设置下次开机时，后面接的 unit 会被启动。 systemctl disable：设置下次开机时，后面接的 unit 不会被启动。 systemctl status：目前后面接的这个 unit 的状态，会列出有没有正在执行、开机时是否启动等信息。 systemctl is-active：目前有没有正在运行中。 systemctl is-enable：开机时有没有默认要启用这个 unit。 systemctl kill ：不要被 kill 这个名字吓着了，它其实是向运行 unit 的进程发送信号。 systemctl show：列出 unit 的配置。 systemctl mask：注销 unit，注销后你就无法启动这个 unit 了。 systemctl unmask：取消对 unit 的注销 序： dhcp：自动分配DNS：域名与IP的对照表","categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://yanjiuzhe.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://yanjiuzhe.github.io/tags/Linux/"}],"author":"书生"}],"categories":[{"name":"博客篇","slug":"博客篇","permalink":"https://yanjiuzhe.github.io/categories/%E5%8D%9A%E5%AE%A2%E7%AF%87/"}],"tags":[{"name":"计算机","slug":"计算机","permalink":"https://yanjiuzhe.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"},{"name":"python","slug":"python","permalink":"https://yanjiuzhe.github.io/tags/python/"},{"name":"爬虫","slug":"爬虫","permalink":"https://yanjiuzhe.github.io/tags/%E7%88%AC%E8%99%AB/"},{"name":"编程语言","slug":"编程语言","permalink":"https://yanjiuzhe.github.io/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"数据库","slug":"数据库","permalink":"https://yanjiuzhe.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"pyMySQL","slug":"pyMySQL","permalink":"https://yanjiuzhe.github.io/tags/pyMySQL/"},{"name":"Java","slug":"Java","permalink":"https://yanjiuzhe.github.io/tags/Java/"},{"name":"前端","slug":"前端","permalink":"https://yanjiuzhe.github.io/tags/%E5%89%8D%E7%AB%AF/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://yanjiuzhe.github.io/tags/JavaScript/"},{"name":"HTML5","slug":"HTML5","permalink":"https://yanjiuzhe.github.io/tags/HTML5/"},{"name":"CSS","slug":"CSS","permalink":"https://yanjiuzhe.github.io/tags/CSS/"},{"name":"Linux","slug":"Linux","permalink":"https://yanjiuzhe.github.io/tags/Linux/"}]}